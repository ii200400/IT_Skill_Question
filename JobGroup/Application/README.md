`목차`

* [4대 컴포넌트](#4대-컴포넌트)
  + [Activity](#activity)
    - [Activity 생명주기](#activity-생명주기)
    - [1. onCreate()](#1-oncreate--)
    - [2. onStart()](#2-onstart--)
    - [3. onResume()](#3-onresume--)
    - [4. onPause()](#4-onpause--)
    - [5. onStop()](#5-onstop--)
    - [7. onDestroy()](#7-ondestroy--)
    - [6. onRestart()](#6-onrestart--)

# 어플리케이션

모바일 어플리케이션을 공부하기 위해서 어떤 것을 배워야 하는지 찾아보고 정리하고자 만들었다.

아래는 정리하고자하는 목록이다.

```
디자인 패턴 (mvc, mvp, mvvm)
UI (jetpack, custom UI)
4대 컴포넌트 (Activities, Services, BroadcaseReceivers, ContentProviders)
Activity 생명주기
framework
비동기 통신 (AsyncTask, Coroutine)
API (RESTful API)
유닛 테스트
디버깅
```

참고 : https://jhpop.tistory.com/121

## 4대 컴포넌트

### Activity

액티비티는 안드로이드의 가장 기본적이고도 중요한 구성요소이다.   
`main()` 함수로 시작하는 프로그래밍 패러다임과는 다르게 안드로이드 시스템은 수명 주기의 특정 단계마다 해당하는 특정 콜백을 함수를 호출하여 액티비티를 코드를 진행한다.

앱은 적어도 하나의 액티비티를 가져야 한다.
액티비티는 기본적으로 UI가 표현될 창을 제공한다. UI는 전체화면이 될 수도 있고 다른 액티비티 위에 작게 떠 있을 수도(대화상자) 있다.

앱의 기본 단위가 되며 하나의 진입점의 역할을 한다.
앱에는 많은 액티비티로 구성되며 최소 하나의 액티비티를 가져야 한다, 일반적으로 앱에서 하나의 액티비티가 기본 액티비티가 되어 앱을 실행할 때 가정 먼저 보일 화면을 구성한다.

#### Activity 생명주기

화면에서 나타나는 액티비티는 생성부터 소멸까지 다양한 상태를 거치는데 이러한 상태들의 과정을 이해하는 것은 중요하다. 다양한 앱들이 서로 간섭하거나 사용자가 앱을 조작하면서 앱이 생각과는 다르게 작동할 수도 있기 때문이다.   
아래와 같은 상황을 떠올려보자.

1. 앱을 사용하다가 다른 앱으로 전환할 때 강제 종료되는 경우   
: 유튜브 보다가 공유하기를 눌러서 카카오톡을 켰는데 유튜브가 강제 종료된다고 상상해보자

2. 앱을 사용하고 있지 않은데 리소스가 낭비되는 경우   
: 산속에서 GPS를 잡다가 안되서 포기하고 잠금 상태로 두었다고 치자.   
그리고 나중에 다시 폰을 켜보니 앱이 계속 GPS를 잡는다고 배터리를 다 사용했다고 상상해보자

3. 앱에서 나갔다가 다시 들어왔는데 사용자의 진행 상태가 저장되지 않은 경우   
: 게임 다운로드가 너무 오래 걸려서 잠시 카톡 보내고 왔는데 다시 처음부터 받아야 한다고 상상해보자

4. 화면 가로/세로 전환을 할 경우, 강제 종료되거나 진행 상태가 저장되지 않은 경우   
: 누워서 웹툰보다가 반대쪽으로 돌아누웠는데 앱이 갑자기 꺼졌다고 상상해보자

만일 생명주기를 알고 있지 않다면 위의 문제들를 해결하기 어려울 것이다.   
액티비티는 새로운 상태로 바뀌기 위해서 6개의 콜백함수 `onCreate()`, `onStart()`, `onResume()`, `onPause()`, `onStop()`, `onDestroy()` 를 사용한다. 이 함수들이 언제 불리고 어떤 역할을 가지는지 정리할 것이다.   

<img src="https://developer.android.com/guide/components/images/activity_lifecycle.png?hl=ko" width="300">   
안드로이드 디벨로퍼 사이트의 액티비티 생명주기 사진

#### 1. onCreate()

액티비티가 생성되었을 때 가장 먼저 실행되면서도 필수적인 콜백으로 단 한 번만 불린다.   

액티비티 최초 실행 시에만 해야 할 작업을 넣어주며 보통은 `setContentView()` 호출과 같은 화면 레이아웃 정의(사용자 인터페이스 선언), `ViewModel` 및 `savedInstanceState`을 통한 UI 관련 데이터를 저장 및 관리, 멤버 변수 정의 등을 넣어준다.

액티비티는 해당 메소드의 실행 이후 바로 `onStart()` 콜백을 호출한다.

#### 2. onStart()

`onCreate()` 혹은 `onRestart()` 콜백 이후 불리는 콜백이다.   
사용자에게 화면이 표시되지만 액티비티는 아직 포그라운드에 머물러 있으며 상호작용이 되지 않는다.   

화면이 보일때 마다 실행되어야 하는 코드를 넣어준다. UI를 관리하는 코드를 초기화 하는 등의 코드가 들어간다.   

작은 대화상자가 액티비티 위에 생성된 경우, 액티비티의 일부는 대화상자 뒤에서 사용자에게 계속 보여야 하므로 대화상자가 닫힌다고 해도 해당 함수가 불리지 않는다.   

해당 메소드는 매우 빠르게 완료되고 직후 시스탬이 `onResume()` 콜백을 호출한다.

#### 3. onResume()

액티비티가 포그라운드에 표시되고 사용자와 상호작용을 시작하기 직전 불리는 콜백함수이다.   
액티비티가 일시정지(`Paused`) 되어있다 재개되거나 `onStart()` 작업이 완료되는 경우 불린다.   

액티비티가 사용자와 상호작용을 시작 작업을 한다. 예를 들면 잠시 꺼둔 GPS 통신이나 카메라를 다시 작동시키는 것 등이 있다.

또한 공식문서에 따르면 초기화 작업을 실행한 수명 주기 이벤트에 상응하는 이벤트에 리소스를 해제하라고 한다. ON_START 이벤트 이후에 무언가를 초기화하는 경우, ON_STOP 이벤트 이후에 이를 해제하거나 종료하고 ON_RESUME 이벤트 이후에 초기화하는 경우, ON_PAUSE 이벤트 이후에 해제하자.

액티비티는 해당 콜백이 끝나면 Resumed 상태에 머무르며 사용자와 상호작용을 진행하다가 인터럽트가 발생하면 `onPause()` 콜백을 호출한다.

#### 4. onPause()

언제나 `onResume()` 콜백 후에, 액티비티가 포커스를 잃고 포그라운드에서 백그라운드로 옮겨지면 불리는 콜백이다. 포커스를 잃는 상황은 대표적으로 다른 앱이 호출되거나(전화가 오거나),대화상자가 열리거나, 핸드폰의 화면이 꺼지는 상황이 있다.   
참고로 멀티 윈도우 모드 혹은 대화상자와 같은 액티비티가 완전히 가리지 않는 창이 나온 경우에는 포그라운드에 머문다고 한다.   

액티비티가 백그라운드에 있을 때 실행할 필요가 없는 기능을 일시중단하거나 리소스를 해제하는 작업을 진행한다. 하지만 앱이나 사용자 데이터 송수신, 데이터베이스 트랜잭션과 같이 저장 작업 등 무거운 작업은 하지 말아야 한다.   
이유는 해당 콜백은 빠르게 종료되기 때문에 저장하는 작업이 콜백보다 오래 걸릴 수 있기 때문이다.

만약 인터럽트 이벤트가 대화상자 호출과 같이 액티비티가 사용자에게 보이는 형태로 남아있다면 해당 액티비티는 `Paused` 상태로 유지된다. 이후 다시 액티비티가 포커스를 얻어 다시 재개된다면 `onResume()` 콜백이, 그렇지 않고 사용자에게 액티비티가 전혀 보이지 않게된다면 `onStop()` 콜백이 호출된다.

#### 5. onStop()

액티비티가 사용자에게 보이지 않게 되었을 때 불리는 콜백이다. `onPause()` 콜백 이후에만 불릴 수 있다.

일반적으로 실행하던 작업을 멈추거나 멈추게될 작업을 계속 실행시키는 코드를 적어넣는다. 대표적으로 화면이 꺼진 네비게이션이 GPS 수신을 잠시 멈추는 것과 화면이 꺼져도 게임 다운로드를 계속하는 기능, 애니메이션을 일시 중지하는 등의 작업이 있다. 또한 `onPause()`에서 하지 못했던 무거운 작업들을 수행하기도 한다.

해당 콜백 이후에는 사용자의 행동에 따라 액티비티가 다시 시작되는 `onRestart()` 콜백이나 액티비티를 종료하는 `onDestroy()` 콜백을 호출한다.   

**참고로** 앱의 메모리가 부족한 경우 시스탬이 `Stopped` 상태에 있는 액티비티가 포함된 프로세스 메모리를 해제하는 경우도 있다. 이런 경우를 대비하여 `ViewModel`이나 `onSaveInstanceState()`을 활용하여 UI 상태를 저장하는 코드가 필요하기도 하다.

#### 7. onDestroy()

액티비티가 소멸되기 전에 호출되는 콜백이다. 일반적으로는 `finish()`가 호출되어 액티비티가 종료되거나 액티비티의 구성이 변경(화면 회전 혹은 멀티 윈도우 모드)될 때 해당한다.

`onStop()`에서 아직 해제하지 않은 모든 리소스들을 해제하거나 액티비티 구성이 변경되어 액티비티가 다시 생성될 경우를 대비하여 `ViewModel`이나 `onSaveInstanceState()`에 관한 작업을 넣어준다.

액티비티가 종료되는 경우 해당 콜백이 마지막이 되고 구성 변경으로 해당 콜백이 호출되었다면 시스템은 바로 새 액티비티를 생성하고 해당 액티비티의 `onCreate()`를 호출한다. 어떤 상황이던 한번 `onDestroy()`가 호출된 액티비티는 종료가 된다.

#### 6. onRestart()

공식 홈페이지에는 따로 설명이 없으나 제공되는 사진으로 유추해볼 때는 `onStop()` 콜백 이후 `Stopped` 상태를 유지하던 액티비티가 다시 사용자에게 보여질 때 불려오는 콜백이다.

##### 참고

+ [안드로이드 액티비티 생명주기 (Activity Life cycle)](https://todaycode.tistory.com/25)
+ [활동 수명 주기에 관한 이해(developer.android)](https://developer.android.com/guide/components/activities/activity-lifecycle?hl=ko)
