## 2. C++ 참조자(레퍼런스)의 도입

배우는 내용

- 기초적인 함수의 사용
- C++ 레퍼런스(reference, 참조자) 의 도입
- 레퍼런스 배열과 배열의 레퍼런스

### reference (참조자)

C와 다르게 C++ 에 새로 도입된 새로운 개념인 레퍼런스를 알아보자. 레퍼런스는 다른 변수나 상수를 가리키는 포인터와는 다른 방식이다.

```
#include <iostream>

using std::cout;
using std::endl;

int main() {
	int x;
	int& y = x;
	// 레퍼런스(y)의 레퍼런스(z)가 아니라 변수(x)의 레퍼런스(z)가 된다.
	// 즉, int&& z 가 아니고 y와 z 모두 x의 참조자가 된다.
	int& z = y;

	x = 1;
	cout << "x : " << x << " y : " << y << " z : " << z << endl;

	y = 2;
	cout << "x : " << x << " y : " << y << " z : " << z << endl;

	z = 3;
	cout << "x : " << x << " y : " << y << " z : " << z << endl;
}
```

![image](https://github.com/ii200400/IT_Skill_Question/assets/19484971/5e94f25f-eedc-4eb8-9350-f61e2331f4cc)

위와 같이 참조자는 타입 뒤에 `&`을 붙여 만들 수 있다. 위의 코드 기준으로 `another_a` 는 `a`의 참조자(또 다른 이름) 이라고 컴파일러에게 알려주는 것과 같다.

포인터와 유사해보이지만 차이점이 있다.

- 레퍼런스는 반드시 정의와 함께 초기화가 되어야 한다.
- 레퍼런스는 포인터와 다르게 상수이다.
  - 레퍼런스는 한 번 어떤 변수의 참조자가 되면 다른 변수를 참조할 수 없게된다.
- 포인터는 주소값을 저장하고, 레퍼런스는 별명을 지정한다.
  - 레퍼런스는 `*`과 `&` 연산자 없이 데이터에 빠르게 접근할 수 있다.
  - 대표적으로 C++을 통해 입력을 받을 때 사용하는 `cin`는 레퍼런스를 사용하기 때문에 C언어 입력과 다르게 `&`을 필요로 하지 않는다.

### 상수 레퍼런스, 배열 레퍼런스, 레퍼런스 배열

제목대로 상수 레퍼런스, 배열 레퍼런스, 레퍼런스 배열을 살펴볼 것이다. 실습을 해보자.

```
#include <iostream>

using std::cout;
using std::endl;

int main() {
	// 리터럴 상수는 값이 바뀌면 안되기 때문에 레퍼런스는 상수를 참조하지 못한다.
	// const 참조자만 가능하다는 에러가 뜬다.
	//int& ref = 4;

	// 하지만 const 참조자는 가능하다. 값을 대입할 수 없기 때문.
	const int& ref = 4;
	// int a = 4 와 같다.
	int a = ref;
	int& ref2 = a;

	// 레퍼런스는 참조하는 변수의 주소값을 똑같이 출력하지만
	// 예외적으로 리터럴 변수를 참조한 상수 레퍼런스는 리터럴 변수의 주소값을 가지지 않는다.
	cout << &ref << endl;
	cout << &a << endl;
	cout << &ref2 << endl;

	// 레퍼런스 배열은 불가능하다. C++ 규정에서 불가능하다고 언급한다.
	// 실재로 참조배열을 사용할 수 없다는 에러가 뜬다.
	//int& arr[1] = { a };

	// 배열 레퍼런스는 가능하다.
	int arr[3] = { 1, 2, 3 };
	int(&ref3)[3] = arr;

	ref3[0] = 2;
	ref3[1] = 3;
	ref3[2] = 1;

	// 배열의 값이 바뀐 것을 볼 수 있다.
	cout << arr[0] << arr[1] << arr[2] << endl;
	return 0;
}
```

![image](https://github.com/ii200400/IT_Skill_Question/assets/19484971/cfaedb0c-5792-44cb-9aa6-ae5b7494fe97)

위처럼 레퍼런스를 활용하면 다양한 특징이 생겨난다. 정리하면 다음과 같다.

- const 참조자만이 리터럴 상수를 참조할 수 있다.
  - 리터럴 상수는 값이 바뀌면 안되기 때문이다.
  - 리터럴 변수를 참조한 상수 레퍼런스는 리터럴 변수의 주소값을 가지지 않는다.
- C++ 규정상 레퍼런스 배열은 불가능하다.
- 배열 레퍼런스는 가능하다.
  - 단, 정의할 때 배열의 크기를 알려주어야 한다.

> 강의자님은 레퍼런스가 메모리를 가지고 있을 수도 있고 아닐 수도 있어서 레퍼런스 배열을 사용하면 시작 주소를 반환할 수 없어서 불가능하다고 하였다. 개인적으로는 **배열 레퍼런스로 레퍼런스 배열을 참조하면 마치 레퍼런스의 레퍼런스가 가능해지므로 불가능하다**고 생각한다.

### 레퍼런스 반환 함수

```

```

- 레퍼런스를 리턴하는 함수에서 지역 변수의 레퍼런스를 리턴하지 않도록 신경써주어야 한다.
  - 지역변수는 함수 반환 시에 메모리가 해제되기 때문이다.
  - 이처럼 참조하던 것이 사라진 레퍼런스를 댕글링 레퍼런스 (Dangling reference) 라고 부른다.
- 예외적으로 상수 레퍼런스로 리턴값을 받게 되면 해당 리턴값의 생명이 연장된다.

> 나의 실습에서는 지역변수를 참조하는 레퍼런스를 반환해도 문제가 없었다. C언어에서도 같은 문제가 발생했었는데 이유를 아직 찾지 못했다. 버전이 업그레이드 되면서 반환값이 임시적으로 저장되는 곳이 생겼거나 반환값의 수명이 조금 연장되었다고 생각하였다. 안 되야 하는데 되는 경우의 구글링은 너무 어렵다..

### 후기

레퍼런스.. 참 편하고 어려운 녀석이다 허허헣

- [3. C++ 의 세계로 오신 것을 환영합니다. (new, delete)](./3.md)
