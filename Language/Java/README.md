# 2-2 Java

+ JDK(Java Development Kit)

자바 전공반에서 배운 내용을 기초로 작성하였음을 밝힌다.



## 개요

나중에 정리

functional interface를 지원하지만 그렇다고 (함수형 프로그래밍을 지원하지 않는다..? - 잘 못들음) 람다식을 지원하기 위해서 도입했다고 한다.

## JDK (Java Development Kit)

Oracle Corporation 에서 배포한 자바를 통해 응용프로그램을 개발할 때 유용한 소프트웨어들의 집합이다.   

JLS(Java Language Specification ) 및 JVMS(Java Virtual Machine Specification)를 구현하고 Java API(Application Programming Interface)의 Standard Edition(SE)을 제공한다고 하는데...   
필자는 단순히 가상 머신, 컴파일러, 성능 모니터링 도구, 디버거 및 자바의 기본 자료형과 라이브러리 등등을 제공한다고 이해하였다.

<br/>

## JVM (Java Virtual Machine)

언어는 소스코드를 번역하는 시점에 따라 크게 컴파일러 언어와 인터프리터 언어로 나뉜다, 이중에서 자바는 둘 모두의 장점을 활용하는 방식을 가진다.

C나 C++의 경우 사용자가 소스코드(Source Code)를 만들고 컴파일러가 컴파일을 하면 결과물로 기계가 이해할 수 있는 기계코드(Machine Code)로 바꿔준다. 하지만 이러한 컴파일러와 기계코드는 운영체제에 종속적으로 다른 운영체제가 사용할 수 없다는 단점이 있었다.   
즉, 미리 번역본(기계코드)을 만들어 다른 개발자와 공유를 하려고 하여도 운영체제가 다르다면 컴파일러 언어의 장점을 얻을 수 없다는 말이다.

자바는 이것과는 조금 다르게 사용자가 소스코드를 만들면 컴파일러가 **바이트코드**로 변환을 해준다. 이는 JVM이 읽을 수 있는 파일로 운영체제에 종속적이지 않다.   
즉, 어떤 OS 이던지 JVM이 설치되어있다면 자바의 컴파일러가 만든 바이트코드를 읽을 수 있다, 이는 자바의 Write once, Run anywhere의 키워드가 생긴 이유이다.

조금 더 자세한 내용은 [클래스](https://github.com/ii200400/IT_Skill_Question/tree/master/Language/Java#%ED%81%B4%EB%9E%98%EC%8A%A4) 부분에서 정리한다.

<br/>

## Garbage Collection

더 이상 필요가 없는 변수나 객체들을 자동으로 메모리를 해제해주는 기능이다.   
애초에 개발자가 신경을 쓰지 않으면서 메모리 해제가 편리하게 진행되도록 만들기 위해서 만든 것이라 기본적으로 가비지 컬랙션을 신경쓰지 않는 것을 추천한다고 한다. 특히 본인처럼 주니어 개발자라면 더더욱..

구글이 만든 자바와 오라클이 만든 자바가 서로 차이가 있어 약간의 차이가 있지만, 핵심은 크게 다르지 않다고 한다. 

<br/>

## 자바의 자료형

[실습링크day1_type 추가요망]()

자바에서는 자료형을 크게 크기가 이미 정해진 기본형과 크기를 미리 알 수 없는 참조형, 두 가지 자료형으로 나눈다.

### Primitive Type (기본형)

자바가 제공하는 8개의 기본 자료형이 있다.   
boolean(JDK마다 다른 비트수), 정수형 [byte(8), short(16), int(32), long(64)], 실수형 [float(32), double(64)], char(16)이 이에 해당한다.

이들 중 int와 double은 기본형으로 키워드 없이 사용하여도 컴파일러가 이것들이라고 유추하고 진행한다. 물론 추론한 것과 선언한 자료형과 맞지 않다면 에러를 뿜어낸다.

#### Numbers

저장에 사용하는 비트 중 가장 앞의 한 비트는 부호를 나타내는 부호비트(Sign bit)이고 나머지는 실재 값을 저장하는 비트로 쓰인다.

기본적으로 실수형은 정수와 소수를 저장하는 부분으로 나뉘어져 있는데 이진법으로는 소수를 정확하게 표현하기 어려워 정확한 계산이 이루어지지 않을 수도 있다.
이때는 BigDecimal을 사용하는 것도 방법이다.

사칙연산을 수행할 때 오버플로우가 발생할 수 있다.
참고로 오버플로우는 논리오류는 아니다, 개발자가 버그를 만드는 원인이 될 수는 있겠지만..

#### 문자형 (char)

내부적으로 아스키코드와 유니코드로 지정된 숫자값과 매핑이 되어있다.   
몇몇 문자는 외어두는 것이 코딩할 때 편하다!

| 이진법 | 십진법 | 문자|
|------|---|---|
| 0110000 | 48 | '0'|
| 0110001 | 49 | '1'|
| 1000001 | 65 | 'A'|
| 1011010 | 90 | 'Z'|
| 1100001 | 97 | 'a'|
| 1111010 | 123 | 'z'|

### Reference Type (참조형)

기본 자료형은 8개이지만... 참조형은 String, int[] 및 **사용자가 만든 클래스들 모두**가 참조형으로 만드는 만큼의 갯수가 있다.   

C언어의 call-by-reference와 비슷하지만 자바는 해당 기능을 지원하지 않으며 자바와는 실질적으로 다른 개념이라고 한다.

#### Type casting (형 변환)

기본적으로는 기본형끼리, 참조형끼리 형 변환이 가능하다,  boolean은 다른 타입과 호환되지 않는다.

+ 묵시적 형 변환 (promotion)
  + 타입의 크기 혹은 표현 범위가 커지는 방향으로 형 변환이 발생한다.

+ 명시적 형 변환
  + 값 손실이 발생할 수 있으므로 프로그래머의 명시하에 현 변환이 진행된다.

## 배열

[실습링크day1_array 추가요망]()

데이터들을 한꺼번에 저장하여 데이터 관리가 편하도록 존재하는 자료구조이다.   
자료구조에 대한 배열 내용은 [이곳](https://github.com/ii200400/IT_Skill_Question/tree/master/CS/DataStructure#array-and-list)을 확인하자. 여기에서는 자바에서의 배열의 사용방법을 중점으로 서술할 것이다.

자바에서는 new 키워드와 함께 배열을 선언할 수 있다.   

+ new data_type[length];
+ new int [3];
+ int[] point = new int[3];
  + point는 배열을 가리키는 reference 타입 변수가 된다.

개발자가 지정해주지 않았다면 배열의 생성과 동시에 자료형에 대한 default 값으로 초기화를 시켜준다.

| 자료형 | 기본값 | 비고 |
|--------|--------|------|
| boolean| false||
|char|'\u0000'| 공백문자|
|byte,short,int| 0| |
|long|0l| |
|float| 0.0f| |
|double|0.0| |
|참조형 변수| null | 참조하지 않음|

## 클래스

[객체지향 프로그래밍에 대한 간략한 설명](https://github.com/ii200400/IT_Skill_Question/blob/master/CS/Development_common_sense/README.md#%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-object-oriented-programming---oop)은 따로 작성하였고 이곳에는 자바에서 객체지향 프로그래밍이 어떻게 작동되는지 서술하겠다.

이에 관한 [실습 내용 추가 요망]()

### JVM 메모리 구조

간단히 클래스 영역, 스택 영역, 힙 영역 3개의 영역으로 나눌 수 있다.

+ class area
  + 클래스들이 저장되는 영역이다, 클래스의 Static 변수들이 저장되기도 한다.
  + 클래스 선언시에 적재된다. ex) Date d; UserClass user; 등..
+ method stack
  + 로컬 변수나 메소드, 파라미터들이 적재되는 장소이다.   
    대표적인 함수인 main()도 이곳에 가장 적재된다.
  + 참조형과 관련하여 힙 영역을 가리키는 변수의 경우 힙 영역의 주소값이 아닌 JVM 임의의 id값을 저장하고 힙 영역을 참조한다.
  + 이 영역의 메모리를 모두 사용하고도 메모리가 또 필요하다면 스택오버플로우(StackOverflow) 에러가 생긴다.
+ heap
  + 객체의 맴버 변수 및 메소드나 참조타입들의 자료형들이 저장되는 영역이다.
  + 이곳에 존재하면서 어떤 스택영역도 참조하고 있지 않으면 가비지 컬렉터에 의해 소멸된다.


### 추상클래스 (abstract class)

day4
동적 바인딩이라는 것이 무엇이였지.. 오버라이딩과 관련되어있는 것 같은데..
클래스의 상속을

### 인터페이스 (interface)

메소드가 겹쳐 다중상속을 지원하지 않는 자바에서 다양한 기능을 추가할 수 있도록 하기 위해서 만드는 기능들을 만들기 위해 있다.

인터페이스를 사용하는 이유!

+ 구현의 강제로 표준화 처리
  + 표준화된 함수들에 한해서는 언제나 구현을 해주므로 클래스 교체도 손쉽다. 
  + 점 프린터를 레이저 프린터로 바꾸고 싶을 때 단순히 객체 생성을 바꿔주기만 하면 된다.
+ 인터페이스를 통해
+ 서로 상속 관계가 없는 클래스들에게 인터페이스를 통해 다형성 확장
  + 접점은 없는데 비슷한 기능이 있는 클래스에 상속을 사용하여 중복되는 기능을 넣을 수 있도록 한다. 
  + 예를 들어 비행기와 독수리는 관계는 없지만 둘 모두 날 수 있다.
+

모든 멤버변수가 기본적으로 public static, 메소드는 public 이라고 한다

#### default method

인터페이스에 구현부가 있는 메소드를 의미한다.
메소드 명이 겹쳤을 때 어떤 것이 우선되는지 알아보자.

## 접근 제한자

자바에는 4개의 접근제한자가 있다 하나하나 의미를 알아야 클래스나 변수를 잘 사용할 수 있으니 꼭 알아두자!

### 1. final 

더 이상 바뀔 수 없도록 만든다.   
메소드에 사용한 경우(final method) 오버라이드를 막아버리고 변수에 사용한 경우(final variable) 저장된 값을 바꿀 수 없어져 상수화된다.

## 변수와 리터럴

변수는 프로그램에서 특정 타입의 데이터를 담는데 사용하며 이 변수에 소스코드를 통해 직접 데이터를 입력할 때 해당 데이터를 리터럴이라고 한다. (예를 들어 int i = 0; 가 있다면 0이 리터럴이다.)

변수에는 선언시 사용한 타입별, 위치별로 다른 특징과 이름을 가지는데 아래와 같다.

### 타입별



### 선언 위치별

맴버 변수
  + 인스턴스 맴버 변수
  + 클래스 맴버 변수
    + 대표적으로 System.out, System.in 이 있다.

## Generics

다양한 타입의 객체를 다루는 메서드 및 컬렉션 클래스에서 컴파일 시에 타입을 체크한다.   
미리 사용할 타입을 명시해서 객체 타입에 대한 안전성 증대 및 형 변환 번거로움 감소시키는 효과를 준다.

### 표현


## Exception

어떤 원인에 의해 오동작 하거나 비정상적으로 종료되는 경우(Error or exception)를 

이러한 예외 클래스도 구조화하여 계층을 이루고 있다.
런타임에 일어나면 런타임exception, 컴파일때 일어나면 .. 등등 다양한 예외가 있다.

[실습 5일차 링크 추가요망]()

## Collection

java.util라는 많은 데이터를 편리하게 처리할 수 있도록 다양한 기능을 제공하는 패키지 내에 있다.   
아래와 같은 상속관계를 가진다.

+ iterable
  + collection
    + List   
      순서가 있는 데이터의 집합
      ex) ArrayList, LinkedList
    + Set
      순서를 유지하지 않는 데이터의 집합 순서가 없으며 중복을 허용하지 않는다.
      ex) HashSet, TreeSet
    + Map
      key와 value의 쌍으로 데이터를 관리하는 집합, key는 중복이 불가능하고 value는 가능하다.
      ex) HashMap, TreeMap

기본적으로 collection은 아래의 기능을 기본으로 가진다.

|분류|collection 메소드|
|---|-----|
|추가|add(E e)<br>addAll(Collection<?extendsE c>)|
|조회|  --  |
| | |

등등..

[실습 5일차 링크 추가요망]()

## lambda


