# 2-2 Java

- JDK(Java Development Kit)

`목차`

- [개요](#개요)
- [JDK (Java Development Kit)](#jdk-java-development-kit)
- [JVM (Java Virtual Machine)](#jvm-java-virtual-machine)
- [Garbage Collection](#garbage-collection)
- [자바의 자료형](#자바의-자료형)
  - [Primitive Type (기본형)](#primitive-type-기본형)
  - [Reference Type (참조형)](#reference-type-참조형)
- [배열](#배열)
- [클래스](#클래스)
  - [JVM 메모리 구조](#jvm-메모리-구조)
- [변수](#변수)
- [제한자](#제한자)
  - [접근 제한자](#접근-제한자)
- [추상클래스 (abstract class)](#추상클래스-abstract-class)
- [인터페이스 (interface)](#인터페이스-interface)
  - [default method](#default-method)
  - [static method](#static-method)
  - [functional Interface](#functional-interface)
- [Generics](#generics)
  - [표현](#표현)
  - [타입 파라미터 제한](#타입-파라미터-제한)
  - [와일드 카드 `?`](#와일드-카드-)
  - [Generic Method](#generic-method)
- [Exception](#exception)
  - [예외 클래스 계층](#예외-클래스-계층)
  - [예외 처리 (try-catch문)](#예외-처리-try-catch문)
  - [throws](#throws)
- [Collection](#collection)
- [lambda](#lambda)
- [IO Stream](#io-stream)
  - [Node Stream (노드 스트림)](#node-stream-노드-스트림)
  - [Filter Stream (Processing Stream, 보조 스트림)](#filter-stream-processing-stream-보조-스트림)
  - [Scanner](#scanner)
  - [BufferedReader](#bufferedreader)
  - [ObjectStream](#objectstream)
    - [Serialization](#serialization)
- [Parsing](#parsing)

자바 전공반에서 배운 내용을 기초로 작성하였음을 밝힌다.

## 개요

나중에 정리

functional interface를 지원하지만 그렇다고 (함수형 프로그래밍을 지원하지 않는다..? - 잘 못들음) 람다식을 지원하기 위해서 도입했다고 한다.

## JDK (Java Development Kit)

Oracle Corporation 에서 배포한 자바를 통해 응용프로그램을 개발할 때 유용한 소프트웨어들의 집합이다.

JLS(Java Language Specification ) 및 JVMS(Java Virtual Machine Specification)를 구현하고 Java API(Application Programming Interface)의 Standard Edition(SE)을 제공한다고 하는데...  
필자는 단순히 가상 머신, 컴파일러, 성능 모니터링 도구, 디버거 및 자바의 기본 자료형과 라이브러리 등등을 제공한다고 이해하였다.

<br/>

## JVM (Java Virtual Machine)

언어는 소스코드를 번역하는 시점에 따라 크게 컴파일러 언어와 인터프리터 언어로 나뉜다, 이중에서 자바는 둘 모두의 장점을 활용하는 방식을 가진다.

C나 C++의 경우 사용자가 소스코드(Source Code)를 만들고 컴파일러가 컴파일을 하면 결과물로 기계가 이해할 수 있는 기계코드(Machine Code)로 바꿔준다. 하지만 이러한 컴파일러와 기계코드는 운영체제에 종속적으로 다른 운영체제가 사용할 수 없다는 단점이 있었다.  
즉, 미리 번역본(기계코드)을 만들어 다른 개발자와 공유를 하려고 하여도 운영체제가 다르다면 컴파일러 언어의 장점을 얻을 수 없다는 말이다.

자바는 이것과는 조금 다르게 사용자가 소스코드를 만들면 컴파일러가 **바이트코드**로 변환을 해준다. 이는 JVM이 읽을 수 있는 파일로 운영체제에 종속적이지 않다.  
즉, 어떤 OS 이던지 JVM이 설치되어있다면 자바의 컴파일러가 만든 바이트코드를 읽을 수 있다, 이는 자바의 Write once, Run anywhere의 키워드가 생긴 이유이다.

조금 더 자세한 내용은 [클래스](https://github.com/ii200400/IT_Skill_Question/tree/master/Language/Java#%ED%81%B4%EB%9E%98%EC%8A%A4) 부분에서 정리한다.

<br/>

## Garbage Collection

더 이상 필요가 없는 변수나 객체들을 자동으로 메모리를 해제해주는 기능이다.  
애초에 개발자가 신경을 쓰지 않으면서 메모리 해제가 편리하게 진행되도록 만들기 위해서 만든 것이라 기본적으로 가비지 컬랙션을 신경쓰지 않는 것을 추천한다고 한다. 특히 본인처럼 주니어 개발자라면 더더욱..

구글이 만든 자바와 오라클이 만든 자바가 서로 차이가 있어 약간의 차이가 있지만, 핵심은 크게 다르지 않다고 한다.

<br/>

## 자바의 자료형

[링크day1_type 추가요망]()

자바에서는 자료형을 크게 크기가 이미 정해진 기본형과 크기를 미리 알 수 없는 참조형, 두 가지 자료형으로 나눈다.

### Primitive Type (기본형)

자바가 제공하는 8개의 기본 자료형이 있다.  
boolean(JDK마다 다른 비트수), 정수형 [byte(8), short(16), int(32), long(64)], 실수형 [float(32), double(64)], char(16)이 이에 해당한다.

이들 중 int와 double은 기본형으로 키워드 없이 사용하여도 컴파일러가 이것들이라고 유추하고 진행한다. 물론 추론한 것과 선언한 자료형과 맞지 않다면 에러를 뿜어낸다.

#### Numbers

저장에 사용하는 비트 중 가장 앞의 한 비트는 부호를 나타내는 부호비트(Sign bit)이고 나머지는 실재 값을 저장하는 비트로 쓰인다.

기본적으로 실수형은 정수와 소수를 저장하는 부분으로 나뉘어져 있는데 이진법으로는 소수를 정확하게 표현하기 어려워 정확한 계산이 이루어지지 않을 수도 있다.
이때는 BigDecimal을 사용하는 것도 방법이다.

사칙연산을 수행할 때 오버플로우가 발생할 수 있다.
참고로 오버플로우는 논리오류는 아니다, 개발자가 버그를 만드는 원인이 될 수는 있겠지만..

#### 문자형 (char)

내부적으로 아스키코드와 유니코드로 지정된 숫자값과 매핑이 되어있다.  
몇몇 문자는 외어두는 것이 코딩할 때 편하다!

| 이진법  | 십진법 | 문자 |
| ------- | ------ | ---- |
| 0110000 | 48     | '0'  |
| 0110001 | 49     | '1'  |
| 1000001 | 65     | 'A'  |
| 1011010 | 90     | 'Z'  |
| 1100001 | 97     | 'a'  |
| 1111010 | 123    | 'z'  |

### Reference Type (참조형)

기본 자료형은 8개이지만... 참조형은 String, int[] 및 **사용자가 만든 클래스들 모두**가 참조형으로 만드는 만큼의 갯수가 있다.

함수의 파라미터로 값을 넘겨줄 때, 단순히 사용하면 객체의 참조값만을 넘겨주기 때문에 생각과는 다른 코드를 만들 수 있다. 깊은 복사와 얕은 복사를 신경써서 사용해야하는데 이것과 관련해서는 메서드 실습에서 다루겠다.

C언어의 call-by-reference와 비슷하지만 자바는 해당 기능을 지원하지 않으며 자바와는 실질적으로 다른 개념이라고 한다. 또한 힙 영역을 가리키는 스택영역의 변수가 가지는 주소값은 힙 영역의 실재 주소값이 아닌 JVM 임의의 id값이라고 한다.

#### Type casting (형 변환)

기본적으로는 기본형끼리, 참조형끼리 형 변환이 가능하다, boolean은 다른 타입과 호환되지 않는다.

- 묵시적 형 변환 (promotion)

  - 타입의 크기 혹은 표현 범위가 커지는 방향으로 형 변환이 발생한다.

- 명시적 형 변환
  - 값 손실이 발생할 수 있으므로 프로그래머의 명시하에 현 변환이 진행된다.

## 배열

[실습링크1일 array 추가요망]()

데이터들을 한꺼번에 저장하여 데이터 관리가 편하도록 존재하는 자료구조이다.  
자료구조에 대한 배열 내용은 [이곳](https://github.com/ii200400/IT_Skill_Question/tree/master/CS/DataStructure#array-and-list)을 확인하자. 여기에서는 자바에서의 배열의 사용방법을 중점으로 서술할 것이다.

자바에서는 new 키워드와 함께 배열을 선언할 수 있다.

- new data_type[length];
- new int [3];
- int[] point = new int[3];
  - point는 배열을 가리키는 reference 타입 변수가 된다.

개발자가 지정해주지 않았다면 배열의 생성과 동시에 자료형에 대한 default 값으로 초기화를 시켜준다.

| 자료형         | 기본값   | 비고          |
| -------------- | -------- | ------------- |
| boolean        | false    |               |
| char           | '\u0000' | 공백문자      |
| byte,short,int | 0        |               |
| long           | 0l       |               |
| float          | 0.0f     |               |
| double         | 0.0      |               |
| 참조형 변수    | null     | 참조하지 않음 |

## 클래스

[객체지향 프로그래밍에 대한 간략한 설명](https://github.com/ii200400/IT_Skill_Question/blob/master/CS/Development_common_sense/README.md#%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-object-oriented-programming---oop)은 따로 작성하였고 이곳에는 자바에서 객체지향 프로그래밍이 어떻게 작동되는지 서술하겠다.

이에 관한 [실습 내용 2_1일 추가 요망]()

### JVM 메모리 구조

간단히 클래스 영역, 스택 영역, 힙 영역 3개의 영역으로 나눌 수 있다.
정황상 Field는 멤버변수의 설계도가 되는 데이터를 말하는 듯하고 Method는 이름 그대로 멤버 메소드의 설계도가 되는 데이터를 의미하는 것 같다. 말을 할때는 '00클래스의 필드'들은 '00클래스의 멤버변수'들과 같거나 비슷한 의미로 언급했다.

- class area
  - 클래스 자체가 저장되는 영역이다.
  - 클래스의 Field / Method / Type 정보, Static 변수들이 저장된다.
  - 클래스 선언시에 적재된다. ex) Date d; UserClass user; 등..
- method stack
  - 로컬 변수나 메소드, 파라미터들이 적재되는 장소
  - Thread는 해당 영역의 메모리를 각자 할당받아 사용한다.
  - 메소드, 로컬변수들이 호출 순서대로 쌓여나가고 가장 위의 메서드가 동작중인 상태이다.  
    다른 메서드를 호출하면 일시정지가 되고 리턴을 하게되면 메모리를 반납하고 일시정지 상태였던 바로 아래의 메서드가 재시작된다.
  - 해당 영역의 메모리가 꽉 차 부족하게 되면 스택오버플로우(StackOverflow) 에러가 생긴다.
- heap
  - 객체의 맴버 변수 및 메소드나 참조타입들의 자료형들이 저장되는 영역
  - Thread는 해당 영역의 메모리를 다른 Thread와 공유하면서 사용한다.
  - 이곳에 존재하면서 어떤 스택 영역의 변수도 참조하고 있지 않으면 가비지 컬렉터에 의해 소멸된다.

## 변수

변수는 프로그램에서 특정 타입의 데이터를 담는데 사용하며 이 변수에 소스코드를 통해 직접 데이터를 입력할 때 해당 데이터를 리터럴이라고 한다. (예를 들어 int i = 0; 가 있다면 0이 리터럴이다.)

변수에는 선언시 사용한 타입별, 위치별로 다른 특징과 이름을 가지는데 아래와 같다.

### 타입별

타입별 기준으로 나누면 Primitive Type와 Reference Type 두 가지로 나눌 수 있다.
이와 관련해서는 [자료형에 관해 정리한 내용](https://github.com/ii200400/IT_Skill_Question/tree/master/Language/Java#%EC%9E%90%EB%B0%94%EC%9D%98-%EC%9E%90%EB%A3%8C%ED%98%95)을 보는 것이 더 좋다.

### 선언 위치별

- 맴버 변수  
  클래스 영역{}에서 선언한다.

  - 인스턴스 멤버 변수  
    객체마다 고유의 메모리를 차지하며 다른 값을 가질 수 있는 변수
    객체 생성 시 같이 만들어지고 객체가 GC에 의해 소멸될 때 같이 소멸한다.
  - 클래스 멤버 변수  
    static 키워드를 사용하는 모든 객체가 공유하는 멤버 변수  
    클래스 영역에 클래스가 로딩시 생성되고 프로그램 종료시 소멸한다.

- 지역변수  
  클래스 영역 이외의 모든 중괄호 안에 선언되는 변수들  
  Thread 별로 생성된 스택 영역에 차곡차곡 메모리를 할당받는다.
  - 지역 변수  
    함수 내부에서 사용하는 변수  
    선언된 라인이 실행될 때 생성되고 선언된 블록을 벗어날 때 소멸한다.
  - 파라미터 변수  
    함수 선언부에 적힌 변수  
    지역변수와 같은 방식으로 생성하고 소멸한다.

[실습 내용 2_1일 static내용 추가 요망]()

메서드에 대한 설명은 생략한다.
기본적인 내용은 기억을 못할 것 같지 않기 때문, 작성할만한 것은 자바에서는 메서드 반환값이 한 개만 가능하다는 것과 참조형 변수를 파라미터로 넘길때 주의해야 하는것 정도?  
위의 내용은 실습내용에도 있으니 원한다면 살펴보자.

</br>

## 제한자

클래스, 변수, 메서드 선언부에 같이 사용되어 부가적인 의미를 부여하고 사용에 제한을 준다.

### 접근 제한자

클래스, 생성자, 변수나 메서드 등의 선언부에 붙어 해당 요소가 외부에서 사용할 수 있는지 설정하기 위한 4개의 키워드

사용 가능 여부(클래스, 생성자, 멤버)와 접근 가능 범위(내부, 외부, 자손 클래스 전체) 표로 정리하면 아래와 같다.

| 제한자           | 클래스 | 생성자 | 멤버 | 같은 클래스 | 같은 패키지 | 다른 패키지의 자손 클래스 | 전체 |
| ---------------- | ------ | ------ | ---- | ----------- | ----------- | ------------------------- | ---- |
| public           | o      | o      | o    | o           | o           | o                         | o    |
| protected        |        | o      | o    | o           | o           | o                         |      |
| package(default) | o      | o      | o    | o           | o           |                           |      |
| private          |        | o      | o    | o           |             |                           |      |

### 그 외 제한자

1. static  
   클래스 영역의 요소를 설정
2. final  
   더 이상 값이 바뀔 수 없도록 만든다.  
   클래스에 사용하는 경우(final class) 상속이 금지된다. Math 같은 완벽한 클래스에 사용한다.  
   메소드에 사용한 경우(final method) 오버라이드를 막아버리며  
   변수에 사용한 경우(final variable) 저장된 값을 바꿀 수 없어져 상수화된다.

3. abstract
   추상 메서드 및 추상 클래스를 의미한다.
4. synchronized  
   멀티 스레드에서의 동기화 처리

등등이 있다. 보통은 배우면서 자연스럽게 제한자를 배워나간다.

</br>

## 추상클래스 (abstract class)

상속 전용의 클래스로 하나 이상의 추상 메소드를 포함하는 클래스를 의미한다.

구현부가 없는 메서드를 가져 객체 생성이 불가능하며 추상 클래스를 상속하는 다른 일반 클래스들은 추상 메서드를 반드시 오버라이딩하여 구현을 강제하는데 이것을 통해서 프로그램의 안정성을 향상시킬 수 있다.

따로 클래스를 만들 정도의 필요성은 있지만 그렇다고 해당 클래스로 객체를 만들 필요는 없을 때 사용한다. 예를 들어 '삼각형', '사각형', '원' 등의 클래스는 '도형' 이라는 클래스를 상속받지만 '도형' 클래스의 객체는 만들 필요가 없을 때가 그러하다.

추상 클래스 및 메소드는 UML에서 이택릭채(기울임)로 표현한다.

[4일차 실습]()에서 추상클래스와 인터페이스 예시 코드를 확인할 수 있다.

## 인터페이스 (interface)

다중상속을 지원하지 않는 자바에서 다양한 기능을 추가할 수 있도록 하기 위해 있다.  
최고 수준의 추상화 클래스로 모든 메서드가 abstract 형태이지만, JDK 8에서 default method와 static method가 추가되었다고 한다.

class 대신에 interface를 선언하여 인터페이스 클래스를 만들 수 있다.  
인터페이스 클래스의 모든 멤버변수는 public static final 이며 생략 가능하고  
모든 메서드는 public abstract 이며 이 또한 생략 가능하다.

인터페이스 클래스도 extends를 이용해서 다른 인터페이스를 상속받을 수 있다.  
이때 일반 클래스와는 다르게 다중 상속이 가능하다는 특징이 있다.  
아마 바디 부분을 구현하지 않으니 메서드가 겹쳐도 문제가 없는 것 같다.  
일반 클래스가 인터페이스를 상속받을 때는 implements 키워드를 사용해서 상속받으며 이 또한 다중상속이 가능하다.

인터페이스를 사용하는 이유!

- 구현의 강제로 표준화 처리
  - 인터페이스가 가지는 상속한 추상 함수들에 한해서는 언제나 구현을 해주므로
- 인터페이스를 상속한 클래스들 끼리 교체가 용이하다.
- 서로 상속 관계가 없는 클래스들에게 인터페이스를 통한 관계 부여로 다형성 확장
  - 접점은 없는데 비슷한 기능이 있는 클래스에 상속을 사용하여 중복되는 기능을 넣을 수 있도록 한다.
  - 예를 들어 비행기와 독수리는 관계는 없지만 둘 모두 날 수 있다.
- 다른 클래스와는 독립적인 프로그래밍이 가능하다.
- 클래스는 인터페이스를 다중 상속하는 것이 가능하다.
  - 다양한 기능을 인터페이스로 만들어 다른 클래스에 다중 상속해주는 것이 가능하다.
  - 세 번째 특징과 연결하여 인터페이스를 강력하게 만드는 원인이 된다.

첫 번째와 두 번째는 일반적인 클래스도 가지는 특징이지만 나머지는 확실히 인터페이스만의 장점이다.

### default method

인터페이스에 구현부가 있는 메소드를 의미한다. default 키워드를 사용하여 작성이 가능하다.  
상단에 있는 인터페이스에 추상 메소드 하나만 추가해도 하부의 클래스들은 모두 강제로 구현해야 하는 상황으로 인해.. 사람들의 필요에 의해 추가되었다고 한다.  
(defacult 메소드는 이미 구현되 있으므로 반드시 작성할 필요가 없다)

그런데 일반 클래스의 다중상속이 안되는 것과 같은 이유로 문제가 생긴다, 인터페이스들의 default 메서드들와 부모 클래스들의 메소드 명이 겹치는 것인데 여기에는 우선순위가 있다.

1. super class의 메서드와 인터페이스의 default method가 충돌나면 super class가 우선된다!
2. interface 하나에서 default method와 다른 interface의 method(default 유무 무관)가 충돌나면 sub class는 무조건 override를 하여 충돌을 해결한다.

### static method

일반 클래스의 static 메서드와 마찬가지로 객체가 없어도 사용이 가능하며 보통의 static 메서드를 사용하는 것과 같이 인터페이스명을 통해 바로 static 메서드에 접근이 가능하다.

### functional Interface

인터페이스에 메서드가 1개만 있는 경우를 의미한다.  
대표적으로 Comparable가 있으며 이러한 인터페이스들은 람다식을 만들 수 있다.

## Generics

다양한 타입의 객체를 다루는 메서드 및 컬렉션 클래스에서 **컴파일 시에 타입을 체크**하는 기능  
객체를 사용시에 타입 파라미터를 명시해서 객체 타입에 대한 안전성을 증대하고 형 변환에 대한 번거로움을 감소시키는 효과를 준다.

[실습은 4일차 Generics]()을 확인하자

### 표현

클래스 또는 인터페이스 선언 시에 사용할 때에는 <>에 파라미터 타입을 표시하여 사용한다.  
ex) public class ClassName`<T>`{}, public interface InterfaceName`<T>`{}

객체를 생성할 때는 생성쪽과 같은 타입을 넣어주거나 생략해주면 된다.  
ex) ClassName`<String>` generic = new ClassName`<String>`();  
 ClassName`<String>` generic = new ClassName`<>`();  
 ClassName`<String>` generic = new ClassName(); // 이렇게는 안된다.

위에서 사용하는 타입 파라미터(T)는 특별한 알파벳이 아니고 임의의 참조형 타입을 의미한다.  
일반적으로 T-reference Type, E-Element, K-Key, V-Value 를 의미한다.

### 타입 파라미터 제한

필요하다면 `extends` 키워드로 타입 파라미터에 제한을 줄 수 있다.  
제한에는 클래스나 인터페이스를 사용할 수 있으며 여러 개의 제약 조건을 넣을 수도 있다.  
ex) class NumberBox`<T extends Number & Cloneable>` {}  
 => T 에는 Number 이면서 Cloneable인 클래스만을 받는다.  
 class NumberBox`<T super Person>` {}  
 => T 에는 Person과 Person의 조상 클래스만을 받는다.

### 와일드 카드 `?`

단순히 어떤 타입이든 될 수 있다는 표현이다.  
제너릭과는 다르게 어떤 상황에서도 클래스 정의가 전혀 되지 않아 클래스의 이점을 사용할 수가 없으므로 제너릭과 타입 파라미터를 제한하는 표현식과 같이 사용한다.

| 표현                             | 설명                                                                          |
| -------------------------------- | ----------------------------------------------------------------------------- |
| Generic type`<?>`                | 어떠한 타입 파라미터라도 가질 수 있다.                                        |
| Generic type`<? extends Number>` | Number 또는 Number를 상속받은 어떤한 타입이라도 타입 파라미터로 가질 수 있다. |
| Generic type`<? extends T>`      | T 또는 T를 상속받은 어떤한 타입이라도 타입 파라미터로 가질 수 있다.           |
| Generic type`<? super T>`        | T 또는 T의 조상 타입인 어떤한 타입이라도 타입 파라미터로 가질 수 있다.        |

[실습]()을 확인하지 않으면 이해를 하기 힘드므로 실습을 확인하자!

### Generic Method

파라미터와 리턴타입으로 타입 파라미터를 가지는 메서드를 의미한다.  
한 클래스 내에서 여러 클래스가 동일한 타입 파라미터를 사용하는 것 같아도, 클래스 파라미터와 다르게 메서드 파라미터는 각 메서드의 호출시점에 타입이 결정되고 다른 메서드 파라미터와는 독립적이다.

제너릭 메서드는 아래와 같이 작성한다.  
public `<P>` void method (P p){}

호출시에는 아래와 같이 작성한다.  
instance.method(10);  
instance.`<Integer>`method(10);

## Exception

어떤 원인에 의해 오동작 하거나 비정상적으로 종료되는 경우를 의미한다.  
심각도에 따라 에러(error)와 예외(exception)로 구분된다.

- Error
  - 메모리 부족, stack overflow와 같이 한번 발생하면 복구할 수 없는 상황
  - 프로그램의 비 정상적 종료를 막을 수 없다.
    디버깅을 통해 해당 상황이 일어나지 않도록 분석하고 코드를 고쳐야 한다.
- Exception
  - 읽으려는 파일이 없거나 네트워크 연결이 안 되는 정도의 비교적 수습이 쉬운 상황
  - 프로그램 코드를 통해서 해당 상황을 탐지하고 비교적 쉽게 수습을 할 수 있다.
    위의 작업을 예외 처리(exception handling)이라고 한다.

### 예외 클래스 계층

![image](https://user-images.githubusercontent.com/19484971/153316167-eeca9cbf-faa3-44ff-a977-496b93b2ef35.png)

이러한 예외 클래스도 구조화하여 계층을 이루고 있다.  
예외의 처리 방식과 심각성에 따라서 3가지로 구분한다.

- Error 계열
  - Error 클래스와 그것의 하위 클래스들
  - 예외 처리의 대상이 아닌 디버깅의 대상
- Checked exception 계열
  - 예외에 대한 대처 코드가 없으면 컴파일이 진행되지 않는 예외
  - Exception 클래스와 RuntimeException 클래스(Unchecked exception 계열)를 제외한 하위 클래스들
- Unchecked exception 계열
  - 예외 처리가 없어도 컴파일이 진행되는 예외
  - RuntimeException 클래스와 하위 클래스들

### 예외 처리 (try-catch문)

try-catch문을 통해서 예외 처리를 진행한다.  
예외가 발생하면 JVM이 해당하는 **Exception클래스 객체를 생성**한 후 던진다!(throw)  
던져진 exception은 처리할 수 있는 catch 블록에서 처리를 하는데, 적당한 catch 블록을 만나지 못하면 예외 처리에 실패한다.

Exception클래스의 부모 클래스인 Throwable에는 예외를 확인할 메서드가 몇 개 있는데 자주 사용하는 메서드는 아래와 같다. 이 메서드들은 catch문에서 자주 사용된다.

| 메서드            | 설명                                                                                                   |
| ----------------- | ------------------------------------------------------------------------------------------------------ |
| getMessage()      | 에러에 대한 구체적인 메시지를 반환한다.                                                                |
| getCause()        | 예외의 원인이 되는 Throwable 객체 또는 null을 반환한다.                                                |
| printStackTrace() | 예외가 발생된 메서드가 호출되기까지의 메서드 호출 스택을 출력한다. 가장 자주 쓰이는 메서드이기도 하다. |

이후 finally블록이 있다면 예외 발생 여부와 return 상관없이 언제나 실행된다.  
주로 try 블록에서 사용한 리소스를 반납하는데 사용한다.

[실습 5일차 링크 추가요망]()

### throws

try-catch문으로 예외 처리를 하는 것 대신에 해당 예외를 호출한 곳으로 전달(처리위임)하는 키워드이다.  
예외가 없어지는 것이 아니라 단순히 전달, 위임하는 것으로 해당 예외를 받은 메서드는 예외 처리를 하거나 또 다시 위임을 해주어야 한다. 만약 main 함수에서도 throws를 해버린다면 JVM이 받고 결국 프로그램이 터진다고 한다.

## Collection

java.util 이라는 패키지 내에 있으며 데이터를 편리하게 처리할 수 있도록 다양한 기능을 제공한다. 아래와 같은 상속관계를 가진다.

- iterable
  - collection
    - List  
      순서가 있는 데이터의 집합
      ex) ArrayList, LinkedList
    - Set
      순서를 유지하지 않는 데이터의 집합 순서가 없으며 중복을 허용하지 않는다.
      ex) HashSet, TreeSet
- Map
  key와 value의 쌍으로 데이터를 관리하는 집합, key는 중복이 불가능하고 value는 가능하다.
  Collection 클래스를 상속받지는 않지만 Collection Framework를 구성하는 3대 주요 인터페이스이다.
  ex) HashMap, TreeMap

각 클래스에 따라 존재하는 메서드는 ctrl+click으로 찾아 볼 수 있는 파일과 설명으로 확인하자.  
영문으로 적혀있지만 대체적으로는 어렵지 않게 설명이 쓰여있고 공식 설명이다.

[실습 5일차 링크 추가요망]()

### List 클래스 관계도

![image](https://user-images.githubusercontent.com/19484971/153369753-335da5ad-82bd-4755-9a60-6e1ce0d8fdc3.png)

개인적으로 Stack과 Queue가 LinkedList를 상속할 줄 알았는데 전혀 아니라서 놀랐다...  
Stack은 관계가 없고 오히려 LinkedList가 Queue를 상속한다;

### ArrayList

배열로 만든 중간에 빈 공간이 없는 순차적인 데이터 집합(리스트)

배열과는 다르게 크기가 자동으로 변동된다는 특징이 있으나, 자동으로 해준다는 점만 다를 뿐 실질적으로는 배열을 그대로 사용하기 때문에 데이터를 중간에 삽입하거나 삭제하는 작업에 많은 시간이 걸린다는 단점을 그대로 이어받는다. (다 미루거나 당겨와야 하는 시간이 어마어마하다.)

내부적으로는 배열(Object[])을 사용하며 요소를 추가하면 한 칸 더 큰 배열을 만든 후 이전 값을 복사하고 추가한 값을 마지막에 넣는다. 하지만 최초에 크기를 지정하면 크기가 찰 때까지는 위와 같은 작업을 반복하지 않아도 된다.

### LinkedList

각 요소를 Node라는 데이터로 정의하고 노드를 순서대로 연결(주소값을 저장)하여 만든 순차적인 데이터 집합(리스트)

### ArrayList VS LinkedList

| 구분       | 순차적 데이터 추가 (100만건) | 비 순차적 데이터 추가 (10만건) | 조회 (10만건) | 사용                              |
| ---------- | ---------------------------- | ------------------------------ | ------------- | --------------------------------- |
| ArrayList  | 0.22초 빠름                  | 314.44초 느림                  | 0.06초 빠름   | 정적 데이터 사용, 데이터 조회용도 |
| LinkedList | 0.8초 느림                   | 0.05 빠름                      | 208초 느림    | 동적 데이터 추가, 삭제 작업       |

참고로 순차적 데이터 추가라는 것은 가장 뒤 인덱스에서 데이터를 조작하는 것을 말한다.  
위의 시간은 컴퓨터의 성능과 상황에 따라 달라질 수 있는 속도이기 때문에 참고용으로만 읽어주었으면 좋겠다. 또한, 1만건 이하의 적은 데이터를 가지고 따지면 위처럼 큰 속도차이를 보이지 않을 수 있다.

### Set 클래스 관계도

![image](https://user-images.githubusercontent.com/19484971/153698497-3b781d75-e7aa-4a1c-b4f5-01224bd6470b.png)

Set은 중복이 불가능한 자료구조인 것은 맞지만, 모든 Set이 순서가 없다고 생각하면 안된다.  
SortedSet을 상속받은 클래스의 경우 순서는 물론 있고 심지어 정렬도 가능하다.

### Map 클래스 관계도

![image](https://user-images.githubusercontent.com/19484971/153698953-bc64207b-7fe9-4d86-aa21-802f7dd1d3e2.png)

여기서 Hashtable은 과거버전에서만 사용한 클래스로 최근에는 사용하지 않고 HashMap을 자주 사용한다고 한다.

Set과 마찬가지로 순서가 있고 정렬이 가능한 SortedMap이 따로 존재한다.

## lambda

함수를 변수처럼 사용하는 기능을 의미한다.

하지만 객체가 있어야만 함수를 작성할 수 있는 자바의 특성상, 자바의 람다식은 메서드가 1개인 인터페이스나 클래스를 상속받는 새로운 클래스를 빠르게 작성이 가능하도록 만들어주는 기능이다. 보통은 단 1번 사용할 함수를 (어쩔 수 없이 클래스까지 생성하면서) 만들 때 사용한다.

[실습 5일차 링크 추가요망]()

## IO Stream

input의 I와 output의 O를 줄여 I/O라고 작성한다.  
데이터를 송수신 할 때 양 끝단을 Node(노드), 이 둘을 연결하고 데이터를 전송하는 통로와 같은 역할을 하는 것을 Stream(스트림)이라고 한다.

즉, IO Stream은 입력 데이터나 출력 데이터를 전송하는 스트림을 의미한다.

스트림은 데이터를 단방향으로만 전송이 가능하기 때문에 하나의 스트림으로 입력과 출력을 같이 처리할 수 는 없다. 때문에 보통은 입력 데이터를 전송하는 스트림은 입력 스트림, 출력 데이터를 전송하는 스트림은 출력 스트림이라고 한다.

프로그램은 소스를 직접 받아오는 것이 아니라 소스를 받는 스트림 혹은 필터 등등에서 받아오는 것으로 사용하는 입력을 받아오는 클래스의 특징마다 속도나 기능에 차이가 생긴다.

### Node Stream (노드 스트림)

노드에 직접 연결된 스트림을 의미한다.  
데이터 타입에 따라 입출력에 따라 노드의 타입에 따라 스트림이 조금씩 달라지는데, 아래와 같다.

![image](https://user-images.githubusercontent.com/19484971/153707472-a898668e-e679-4799-8bac-26a5f13bee5a.png)

기본적으로는 InputStream과 OutputStream 클래스의 사용법만 알면 대부분은 사용할 수 있다고 한다. 또한 한글은 영문과 다르게 3byte씩 사용하기 때문에 Byte 데이터를 주고받는 Stream 계열 클래스보다는 Char 데이터를 주고 받는 Reader/Writer 계열 클래스들을 더 자주 사용하게 된다고 한다.

[실습 6일차 링크 추가요망]()

### Filter Stream (Processing Stream, 보조 스트림)

다른 스트림에 부가적인 기능을 제공하는 스트림을 의미한다. 다른 스트림으로 부터 데이터를 받아 코더들에게 가공된 데이터를 제공하여 편의성을 증가시킨다.

대표적인 보조 스트림은 아래와 같다.

| 기능                               | byte 기반                                    | char 기반                         |
| ---------------------------------- | -------------------------------------------- | --------------------------------- |
| byte 스트림을 char 스트림으로 변환 | InputStreamReader</br>OutputStreamReader     |                                   |
| 버퍼링을 통한 속도 향상            | BufferedInputStream</br>BufferedOutputStream | BufferedReader</br>BufferedWriter |
| 객체 전송                          | ObjectInputStream</br>ObjectOutputStream     |                                   |

보조 스트림들은 이름이 직관적인 편이라서 자동완성과 함께라면 따로 이름을 외우지 않아도 될 정도이다.

위와 같은 보조 스트림들을 연결해서 사용하는 것을 Stream Chaining(스트림 체이닝)이라고 한다. 참고로 보조 스트림의 close 메서드를 호출하면 노드 스트림의 close가 호출되기 때문에 하나의 스트림만 close하면 된다고 한다.

[실습 6일차 링크 추가요망]()

### Scanner

입력 데이터의 처리를 돕는 자바의 대표적인 클래스 중 하나이다.  
java.util.Scanner을 임포트하여 사용할 수 있다.

파일, 입력 스트림에서 데이터를 읽어 구분자로 토큰화하고 다양한 클래스로 형 변환해주는 편리한 기능이 있다. 하지만 대량의 데이터 처리 시 수행 시간이 비효율적이라는 단점이 있다.

스트림은 아니고 자바에서 기본적으로 제공하는 유틸리티라고 한다. (스트림인줄..;)

### BufferedReader

입출력 시 데이터를 한꺼번에 옮기거나 잠시동안 저장하기 위해 스트림은 버퍼(buffer)를 활용하는 스트림이다.

직접 스트림을 구현하고 형 변환을 해주는 등 구현에 번거로움이 있긴 하지만, 데이터를 한꺼번에 이동시키는 특징이 있기 때문에 Scanner에 비해 속도는 데이터가 많을수록 빨라지는 것을 확인할 수 있다.

### ObjectStream

데이터화된 객체를 전송하는 스트림을 의미한다. 객체를 데이터화 하기 위해서는 Serialization이라는 과정이 반드시 필요하다.

#### Serialization

객체를 파일 등에 저장하거나 네트워크로 정송하기 위해 연속적인 데이터로 변환하는 것  
반대의 경우를 역 직렬화(deserializaion)이라고 한다.

클래스가 Serializable 인터페이스를 상속받으므로서 구현이 가능하다.  
이때 모든 멤버변수는 transient 키워드를 사용하여 제외시키지 않는 이상 Serializable 인터페이스를 구현해야 한다. 참고로 String 타입 데이터는 직렬화가 되어있는 상태와도 같으므로 직렬화할 필요가 없다.

#### Serialization 사용 도중 객체의 멤버변수를 수정하면?

serialVersionUID 라는 키를 활용해서 클래스의 변경여부를 확인한다.  
개발자가 UID를 지정해줄 수도 있지만 그렇지 않은 경우 컴파일러가 자동으로 생성해준다. 저장된 객체의 데이터와 컴파일 시의 클래스 UID가 일치하지 않는다면 InvalidClassException이 발생하기 때문에 설정을 적절히 해주어야 한다.

[실습 6일차 링크 추가요망]()

## Parsing

문서에서 필요한 정보를 얻기위해 태그를 기준으로 내용을 추출하는 과정  
대표적으로 SAX parser, DOM parser 가 있다.

- SAX parser
  - Simple API for XML parser 의 약자
  - 문서를 읽으면서 태그의 시작, 종료 등 이벤트 기반으로 처리하는 방식
  - 빠르게 읽지만, 다양한 조건의 탐색은 어렵다.
- DOM parser
  - Document Object Model
  - 문서를 다 읽고 난 후 문서 구조 전체를 자료구조에 저장하여 탐색하는 방식
  - 자료구조로 만들어 저장하기 때문에 메모리와 시간을 많이 소모하지만, 다양한 조건으로 탐색이 가능하다.

[실습 6일차 링크 추가요망]()
