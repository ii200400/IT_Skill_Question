# 2-2 Java

+ JDK(Java Development Kit)

자바 전공반에서 배운 내용을 기초로 작성하였음을 밝힌다.



## 개요

나중에 정리

functional interface를 지원하지만 그렇다고 (함수형 프로그래밍을 지원하지 않는다..? - 잘 못들음) 람다식을 지원하기 위해서 도입했다고 한다.

## JDK (Java Development Kit)

Oracle Corporation 에서 배포한 자바를 통해 응용프로그램을 개발할 때 유용한 소프트웨어들의 집합이다.   

JLS(Java Language Specification ) 및 JVMS(Java Virtual Machine Specification)를 구현하고 Java API(Application Programming Interface)의 Standard Edition(SE)을 제공한다고 하는데...   
필자는 단순히 가상 머신, 컴파일러, 성능 모니터링 도구, 디버거 및 자바의 기본 자료형과 라이브러리 등등을 제공한다고 이해하였다.

<br/>

## JVM (Java Virtual Machine)

언어는 소스코드를 번역하는 시점에 따라 크게 컴파일러 언어와 인터프리터 언어로 나뉜다, 이중에서 자바는 둘 모두의 장점을 활용하는 방식을 가진다.

C나 C++의 경우 사용자가 소스코드(Source Code)를 만들고 컴파일러가 컴파일을 하면 결과물로 기계가 이해할 수 있는 기계코드(Machine Code)로 바꿔준다. 하지만 이러한 컴파일러와 기계코드는 운영체제에 종속적으로 다른 운영체제가 사용할 수 없다는 단점이 있었다.   
즉, 미리 번역본(기계코드)을 만들어 다른 개발자와 공유를 하려고 하여도 운영체제가 다르다면 컴파일러 언어의 장점을 얻을 수 없다는 말이다.

자바는 이것과는 조금 다르게 사용자가 소스코드를 만들면 컴파일러가 **바이트코드**로 변환을 해준다. 이는 JVM이 읽을 수 있는 파일로 운영체제에 종속적이지 않다.   
즉, 어떤 OS 이던지 JVM이 설치되어있다면 자바의 컴파일러가 만든 바이트코드를 읽을 수 있다, 이는 자바의 Write once, Run anywhere의 키워드가 생긴 이유이다.

### JVM 메모리 구조

간단히 클래스 영역, 스택 영역, 힙 영역 3개의 영역으로 나눌 수 있다.

+ class area
  + 클래스들이 저장되는 영역이다, 클래스의 Static 변수들이 저장되기도 한다.
  + 클래스 선언시에 적재된다. ex) Date d; UserClass user; 등..
+ method stack
  + 로컬 변수나 메소드, 파라미터들이 적재되는 장소이다.   
    대표적인 함수인 main()도 이곳에 가장 적재된다.
  + 참조형과 관련하여 힙 영역을 가리키는 변수의 경우 힙 영역의 주소값이 아닌 JVM 임의의 id값을 저장하고 힙 영역을 참조한다.
  + 이 영역의 메모리를 모두 사용하고도 메모리가 또 필요하다면 스택오버플로우(StackOverflow) 에러가 생긴다.
+ heap
  + 객체의 맴버 변수 및 메소드나 참조타입들의 자료형들이 저장되는 영역이다.
  + 이곳에 존재하면서 어떤 스택영역도 참조하고 있지 않으면 가비지 컬렉터에 의해 소멸된다.

<br/>

## Garbage Collection

더 이상 필요가 없는 변수나 객체들을 자동으로 메모리를 해제해주는 기능이다.   
애초에 개발자가 신경을 쓰지 않으면서 메모리 해제가 편리하게 진행되도록 만들기 위해서 만든 것이라 기본적으로 가비지 컬랙션을 신경쓰지 않는 것을 추천한다고 한다. 특히 본인처럼 주니어 개발자라면 더더욱..

구글이 만든 자바와 오라클이 만든 자바가 서로 차이가 있어 약간의 차이가 있지만, 핵심은 크게 다르지 않다고 한다. 

<br/>

## 자바의 자료형

자바에서는 자료형을 크게 크기가 이미 정해진 기본형과 크기를 미리 알 수 없는 참조형, 두 가지 자료형으로 나눈다.

(실습링크 추가요망)[]

### Primitive Type (기본형)

자바가 제공하는 8개의 기본 자료형이 있다.   
boolean(JDK마다 다른 비트수), 정수형 [byte(8), short(16), int(32), long(64)], 실수형 [float(32), double(64)], char(16)이 이에 해당한다.

이들 중 int와 double은 기본형으로 키워드 없이 사용하여도 컴파일러가 이것들이라고 유추하고 진행한다. 물론 추론한 것과 선언한 자료형과 맞지 않다면 에러를 뿜어낸다.

#### Numbers

저장에 사용하는 비트 중 가장 앞의 한 비트는 부호를 나타내는 부호비트(Sign bit)이고 나머지는 실재 값을 저장하는 비트로 쓰인다.

기본적으로 실수형은 정수와 소수를 저장하는 부분으로 나뉘어져 있는데 이진법으로는 소수를 정확하게 표현하기 어려워 정확한 계산이 이루어지지 않을 수도 있다.
이때는 BigDecimal을 사용하는 것도 방법이다.

사칙연산을 수행할 때 오버플로우가 발생할 수 있다.
참고로 오버플로우는 논리오류는 아니다, 개발자가 버그를 만드는 원인이 될 수는 있겠지만..

#### 문자형 (char)

내부적으로 아스키코드와 유니코드로 지정된 숫자값과 매핑이 되어있다.   
몇몇 문자는 외어두는 것이 코딩할 때 편하다!

| 이진법 | 십진법 | 문자|
|------|---|---|
| 0110000 | 48 | '0'|
| 0110001 | 49 | '1'|
| 1000001 | 65 | 'A'|
| 1011010 | 90 | 'Z'|
| 1100001 | 97 | 'a'|
| 1111010 | 123 | 'z'|

### Reference Type (참조형)

기본 자료형은 8개이지만... 참조형은 String, int[] 및 **사용자가 만든 클래스들 모두**가 참조형으로 만드는 만큼의 갯수가 있다.   

C언어의 call-by-reference와 비슷하지만 자바는 해당 기능을 지원하지 않으며 자바와는 실질적으로 다른 개념이라고 한다.

#### Type casting (형 변환)

기본적으로는 기본형끼리, 참조형끼리 형 변환이 가능하다,  boolean은 다른 타입과 호환되지 않는다.

+ 묵시적 형 변환 (promotion)
  + 타입의 크기 혹은 표현 범위가 커지는 방향으로 형 변환이 발생한다.

+ 명시적 형 변환
  + 값 손실이 발생할 수 있으므로 프로그래머의 명시하에 현 변환이 진행된다.

## 변수

### 타입별



### 선언 위치별

맴버 변수
  + 인스턴스 맴버 변수
  + 클래스 맴버 변수
    + 대표적으로 System.out, System.in 이 있다.
  


## Literal (리터럴)

들은 경험이 없어... 나만..

## 접근 제한자

자바에는 4개의 접근제한자가 있다 하나하나 의미를 알아야 클래스나 변수를 잘 사용할 수 있으니 꼭 알아두자!

### 1. final 

더 이상 바뀔 수 없도록 만든다.   
메소드에 사용한 경우(final method) 오버라이드를 막아버리고 변수에 사용한 경우(final variable) 저장된 값을 바꿀 수 없어져 상수화된다.



