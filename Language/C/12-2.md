## 12 - 2. 포인터는 영희이다! (포인터)

배우는 내용

- 상수 포인터 (`const int*`, `int* const`)
- 포인터의 덧셈, 뺄셈
- 배열과 포인터와의 관계
- `[]` 연산자

### 상수 포인터

포인터는 상수인 자료형을 가리킬 수도 있고 자신이 상수가 될 수도 있다. 실습을 통해 이해하는 것이 빠르다.

```
/* 12-2 1 상수 포인터? */

#include <stdio.h>

int main() {
	int a;
	int b;

	// const int의 포인터인 pa
	const int* pa = &a;

	// pa는 받은 주소값의 데이터형을 수정하지 않도록 선언되어 있으므로..
	//*pa = 3;  // 올바르지 않은 문장
	pa = &b;  // 올바른 문장

	// int의 포인터이면서 상수 포인터인 pa2
	int* const pa2 = &a;

	// pa의 값(주소값)은 수정하지 않도록 선언되어 있으므로..
	*pa2 = 3;  // 올바른 문장
	//pa2 = &b;  // 올바르지 않은 문장

	// const int의 포인터 상수인 pa3
	const int* const pa3 = &a;

	// 둘 다 안 된다!
	//*pa3 = 3;  // 올바르지 않은 문장
	//pa3 = &b;  // 올바르지 않은 문장

	const int c;

	// 가리키는 값이 실재로는 const int라도 정작 pa4 포인터는 제한이 없으므로
	int* pa4 = &c;

	// 수정이 가능하다.
	*pa4 = 3;
	printf("c : %d\n", c);
	*pa4 = 3;

	return 0;
}
```

간단히 정리하면..

- 포인터는 가리키는 변수의 주소값과 데이터, 2가지에 대해 상수를 설정할 수 있다.
  - `const int*`(상수 포인터)은 가리키는 주소의 데이터 수정을 막는다.
  - `int* const pa`(포인터 상수)는 주소값의 수정을 막는다.
  - `const int* const pa`로 둘 모두 수정을 막을 수 있다.
- 포인터가 가리키는 주소값의 자료형이 상수라고해도 포인터가 상수가 아니라면 수정이 가능하다.

### 포인터 연산

포인터도 사칙연산이 가능하다. 실습을 진행해보자

```
/* 12-2 2 포인터의 덧셈 */

#include <stdio.h>

int main() {
	int a;
	char b;
	double c;
	int* pa = &a;
	char* pb = &b;
	double* pc = &c;

	// int는 4바이트만큼
	printf("(pa - 1) 의 값 : %p \n", pa - 1);
	printf("pa 의 값 : %p \n", pa);
	printf("(pa + 1) 의 값 : %p \n", pa + 1);

	// char는 1바이트만큼
	printf("pb 의 값 : %p \n", pb);
	printf("(pb + 1) 의 값 : %p \n", pb + 1);

	// double은 8바이트만큽 차이가 난다.
	printf("pc 의 값 : %p \n", pc);
	printf("(pc + 1) 의 값 : %p \n", pc + 1);

	int d;
	int* pd = &d;
	// 덧셈은 정수여야 한다는 에러가 나온다.
	//int* pad = pa + pd;

	return 0;
}
```

결과는 아래와 같다.

![image](https://github.com/ii200400/IT_Skill_Question/assets/19484971/e3935913-205a-4d13-bfe3-7049103fe44a)

의미를 정리하면 다음과 같다.

- 포인터를 1씩 증감하면 선언시 지정된 자료형의 크기만큼 커지고 작아진다.
  - 이는 배열을 활용하기 위함이다. (실습은 바로 아래에서..)
- 포인터끼리 더하는 것 자체는 문제가 없지만, 의미있는 주소가 나오는 것은 아니기 때문에 C언어에서는 허용하지 않는다.

### 배열과 포인터

위에서 확인한 포인터의 증감 방식과 배열의 원소들이 메모리 상에서 순차적으로 저장되는 점을 기억하면 배열의 원리를 조금 이해할 수 있다.

```
/* 12-2 3 배열의 각 원소 별 주소 */

#include <stdio.h>

int main() {
    int arr[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
    int* parr;
    int i;
    parr = &arr[0];
    // 아래 코드는 윗코드와 같은 의미이다.
    // 하지만 그렇다고 변수 arr이 포인터인 것은 아니다.
    // C언어가 제공하는 기능 중 하나일 뿐이다.
    //parr = arr;

    // 엄연히 다른 자료형이다.
    printf("Sizeof(arr) : %d \n", sizeof(arr));
    printf("Sizeof(parr) : %d \n\n", sizeof(parr));

    for (i = 0; i < 10; i++) {
        printf("arr[%d] 의 주소값 : %p \n", i, &arr[i]);
        printf("(parr + %d) 의 값 : %p \n", i, (parr + i));

        if (&arr[i] == (parr + i)) {
            /* 만일 (parr + i) 가 성공적으로 arr[i] 를 가리킨다면 */
            printf(" --> 일치 \n");
        }
        else {
            printf("--> 불일치\n");
        }

        printf("arr[%d] = %d , *(parr + i) = %d \n\n", i, i, *(parr + i));
    }

    printf("arr[3] : %d \n", arr[3]);
    printf("3[arr] : %d \n", 3[arr]);
    printf("*(3+a) : %d \n", *(arr + 3));

    // 이런것도 가능하다
    printf("?!? : %d \n", arr[0][arr]);

    return 0;
}
```

결과창이 조금 길어서 생략하겠다. 알 수 있는 내용은 아래와 같다.

- 배열의 이름을 사용시 암묵적으로 첫 번째 원소를 가리키는 포인터로 타입 변환된다.
  - sizeof 연산자나 주소값 연산자(&)와 사용되는 경우는 제외한다.
  - 그렇다고 배열과 포인터는 같은 자료형인 것은 아니다.
- `arr[1]`과 `1[arr]`과 `arr+1` 같은 의미로 같은 주소를 가리킨다.
  - 자주 잊지만 `[]`은 연산자이다. `()`또한 그렇다. 둘은 연산자 최우선 순위이다.
  - `[]`연산자는 피연산자로 정수와 포인터 2개가 필요하다.
  - `arr[i]` 와 같은 문장은 사실 컴파일러에 의해 `*(arr + i)` 로 변환된다.

### 후기

`1[arr]`가 되는 것은 몰랐는데 신기하다. 연산자의 작동방식을 이해하니 사용할 수 있게 되었다! 최근에 있던 재미있는 코딩 중 하나가 되었다. 그런데 이중배열일 때는 배열의 내부작업이 어떻게 진행되는지 좀 햇갈린다. (다음강의에 설명이 있었다!)

- [12-3. 포인터는 영희이다! (포인터)](./12-3.md)
