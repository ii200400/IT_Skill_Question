## 12-3. 포인터는 영희이다! (포인터)

배우는 내용

- 2 차원 배열을 가리키는 포인터 (배열 포인터)
- 포인터 배열
- 더블 포인터 (\*\*)

### 포인터의 포인터

원래는 1차원 배열부터 내용이 시작하지만 이전 강의하고 내용이 겹쳐서 생략하였다.

포인터를 가리키는 포인터를 실습해보겠다.

```
/* 12-3 1 포인터의 포인터 */

#include <stdio.h>

int main() {
	int a;
	int* pa;
	int** ppa;

	pa = &a;
	ppa = &pa;

	a = 3;

	printf("a : %d // *pa : %d // **ppa : %d \n", a, *pa, **ppa);
	printf("&a : %p // pa : %p // *ppa : %p \n", &a, pa, *ppa);
	printf("&pa : %p // ppa : %p \n", &pa, ppa);

	return 0;
}
```

![image](https://github.com/ii200400/IT_Skill_Question/assets/19484971/756b7b5c-2a7c-4e49-8a85-3590b98cccb7)

특별할 것이 없는 결과이다. 그림으로 나타내면 아래와 같다.

![](https://modoocode.com/img/161550244AFEB8B93D7FD2.webp)

> [모두의 코드](https://modoocode.com/25)

### 2차원 배열의 `[]` 연산자

전에도 진행했던 2차원 배열에 대한 실습을 진행한다.

```
/* 12-3 2 2차원 배열 주소값 */

#include <stdio.h>

int main() {
	int arr[2][3] = { {1, 2, 3}, {4, 5, 6} };

	// 암묵적으로 arr과 arr[0]는 arr[0][0]의 주소값으로 변환된다.
	printf("arr : %p \n", arr);
	printf("&arr : %p \n", &arr);
	printf("arr[0] : %p \n", arr[0]);
	printf("&arr[0][0] : %p \n", &arr[0][0]);

	printf("arr[1] : %p \n", arr[1]);
	printf("&arr[1][0] : %p \n", &arr[1][0]);

	// 행과 열의 개수는 아래와 같이 구한다.
	printf("전체 크기 : %d \n", sizeof(arr));
	printf("총 열의 개수 : %d \n", sizeof(arr[0]) / sizeof(arr[0][0]));
	printf("총 행의 개수 : %d \n", sizeof(arr) / sizeof(arr[0]));

	return 0;
}
```

이전에 했던 내용을 다시 확인하는 것이기 때문에 중요한 내용만 정리하고 넘어가겠다.

- `int arr[][]` 에서 `arr`와 `arr[0]` 과 `&arr[0][0]`은 같다.
  - `arr`과 `arr[0]`을 C언어가 암묵적으로 타입 변환을 시켜주는데 `arr[0][0]`과 같은 내용으로 변하는 것
  - 본래 두 개의 변환 전 내용은 다르다.
- sizeof와 & 연산자는 암묵적 변환을 예외로 한다.
  - `sizeof`를 활용해서 행과 열의 크기를 계산할 수 있다.
  - `arr`과 `&arr`은 같은 주소값이다.
  - 이러한 이유는 C언어의 기반이 B언어인데, B언어보다 메모리 효율성을 높이다가 생겼다고 한다.

### 배열 포인터

다중 배열의 포인터를 선언할 때에는 아래와 같이 형식을 신경써주어 선언해주어야 한다.

```
/* 12-3 3 배열의 포인터 */

#include <stdio.h>

int main() {
	int arr[2][3] = { {1, 2, 3}, {4, 5, 6} };
	int (*parr)[3];  // 괄호를 꼭 붙여야 한다.

	parr = arr;  // parr 이 arr 을 가리키게 한다.

	printf("parr[1][0] : %d , arr[1][0] : %d \n", parr[1][0], arr[1][0]);

	int brr[10][3];
	int crr[2][5] = { {1,2,3,4,5}, {6,7,8,9,10} };

	// 항상 두번째의 크기가 3인 배열만 넣을 수 있다.

	parr = arr;  // O.K
	parr = brr;  // O.K
	parr = crr;  // 크기가 다르지만 가능하다. (예전버전은 오류)
	// 알고있는 크기가 달라서 다른 값을 출력하는 모습을 볼 수 있다.
	printf("parr[1][0] : %d , crr[1][0] : %d \n", parr[1][0], crr[1][0]);

	int** ppa = arr;
	// 출력이 되지 않는다. 해석하면 7이라는 주소값을 읽으라는 의미가 된다.
	//printf("ppa[1][1] : %d \n", ppa[1][0]);
	// 출력은 되지만 int* 형식을 %d로 출력한다고 경고가 생긴다.
	printf("ppa[1] : %d \n", ppa[1]);

	return 0;
}
```

`int arr[a][b]` 라고 정의된 2 차원 배열을 생각해봅시다. 여기서 `arr[x][y]` 라는 원소를 참조할 때 이 원소의 주소값은 아래와 같이 계산한다.

`arr+4bx+4y`

즉, 제공된 x와 y 외에도 b가 필요하기 때문에 다중배열 포인트는 `int (*p)[b]`와 같이 정의하는 것이다.

다음으로 `ppa[1][1]`는 `*(*(ppa + 1) + 1)`과 같은 의미이고 `ppa`는 `int*`의 포인터이므로 `*(ppa + 1)`는 (`int*`의 크기는 8) 8\*1만큼 주소를 이동시킨다. 때문에 위의 코드에서 `*(ppa + 1)`는 3이고 자료형은 `int`의 포인터(`int`의 크기는 4)이므로 여기에 +1을 하면 7이된다. `*(*(ppa + 1) + 1)`는 7이라는 주소값의 데이터이기 때문에 출력이 잘 안되는 것이다.

### 포인터 배열

말 그대로 포인터들의 배열, 위의 배열을 가리키는 포인터가 아니다. 어려우면 뒤의 단어만 중점으로 보면 된다. 포인터 배열은 배열, 배열 포인터는 포인터이다.

```
/* 12-3 4 포인터배열*/

#include <stdio.h>

int main() {
	// 단순히 포인터의 배열이다. 어려운 내용은 없으니 설명은 생략
	int* arr[3];
	int a = 1, b = 2, c = 3;
	arr[0] = &a;
	arr[1] = &b;
	arr[2] = &c;

	printf("a : %d, *arr[0] : %d \n", a, *arr[0]);
	printf("b : %d, *arr[1] : %d \n", b, *arr[1]);
	printf("b : %d, *arr[2] : %d \n", c, *arr[2]);

	printf("&a : %p, arr[0] : %p \n", &a, arr[0]);

	return 0;
}
```

강의에서 포인터 배열의 내용은 단순하게 실습만하고 넘어갔다. 추가적인 내용은 다음 강의에서 순차적으로 다룰 예정이라고 하니 끝까지 진행해보아야겠다.

### 후기

배열의 작동방식을 이해시키려고 하는 것은 좋은데 이번 강의는 너무 복잡하게 설명한 것 같다. 오히려 모든 강의를 쭉 읽고 다시 정리하는게 더 빨랐을 것이다.

그래도 과거에 이해도 못하고 외워서 선언하던 배열의 포인터 선언을 이해해서 좋았다.

- [13-1. 마술 상자 함수(function)](./13-1.md)
