## 15-2. 일로와봐, 문자열(string)

배우는 내용

- 버퍼(stdin)에 대한 이해
- 고질적인 scanf 문제에 대한 해결 및 이해

### 버퍼(buffer)

버퍼는 사용자의 입력을 한꺼번에 처리할 수 있도록 컴퓨터가 사용하는 임시 저장장소이다. (강의에서는 물을 옮길 때 사용하는 양동이와 같은 도구라고 설명하기도 했다.)

버퍼에도 종류가 다양한데 그 중에서도 키보드의 입력을 처리하는 버퍼는 `입력 버퍼`, 혹은 `stdin` (흔히 입력 스트림) 이라 부르는 것이다.

`stdin`는 아래의 실습처럼 자주 쓰인다.

```
/* 이상한 scanf */
#include <stdio.h>
int main() {
  int num;
  char c;

  printf("숫자를 입력하세요 : ");
  scanf("%d", &num);

  printf("문자를 입력하세요 : ");
  scanf("%c", &c);
  return 0;
}
```

실행시켜보면 아래의 사진처럼 문자를 입력받지 않고 빠르게 끝내버리는 현상이 일어나는 것을 볼 수 있다.

![image](https://github.com/ii200400/IT_Skill_Question/assets/19484971/00198026-3f94-4c72-aace-5351718cde3d)

이유는 다음과 같다. (설명이 아주 길다.)

우선 ` `(스페이스), `\n`, `\t`(tab) 세 문자는 공백문자라고 한다. `stdin`은 작업에 따라 데이터를 버퍼에서 가져오는데 서식지정자에 따라서 읽어오는 방법이 다르다.

`%d`와 같은 숫자와 관련된 서식지정자는 수가 아닌 데이터가 와도 입력을 종료하고 공백문자라면 수가 입력될 때까지 입력을 계속 기다린다. 그리고 `%c` 서식지정자는 공백문자를 포함한 하나의 데이터를 가져온다.

위의 내용을 숙지하고 코드를 이해해보자.

`num`에 넣을 숫자를 입력하면 숫자 데이터는 `stdin`이 가져가고 버퍼에는 개행문자(`\n`)만이 남는다. 이후 `c`에 넣을 문자를 입력하기 `stdin`이 버퍼에서 남은 개행문자를 바로 `c`에 넣어버리기 때문에 사용자를 기다리지 않고 바로 끝나는 것이다.

그렇다면 문자열인 `%s`는 어떻게 될까?

```
/* 15-2 2 이상한 scanf */

#include <stdio.h>

int main() {
	char str[30];
	int i;

	printf("i : ");
	scanf("%d", &i);
	printf("str : ");
	scanf("%s", str);

	printf("str : %s", str);

	return 0;
}
```

![image](https://github.com/ii200400/IT_Skill_Question/assets/19484971/ee40e37e-050e-4df9-bc04-e1753a46b7cc)

전과 다르게 입력을 기다려준다. 왜 그럴까?

`%c`와는 다르게 `%s`는 남아있는 공백문자를 버리고 실질적인 데이터 이후의 공백문자를 인식한다. (하지만 물론 `%s`를 입력받고 남은 개행문자는 또 버퍼에 남는다.)

즉, `%s`와 `%d`와 같은 숫자 서식지정자는 버퍼에 남은 공백문자를 신경쓰지 않고 쓸 수 있고 `%c`는 버퍼에 남은 데이터를 신경써주어야 한다.

하지만 여기서 문제는 끝나지 않는다.

```
/* 15-2 3 마지막 stdin 예제 */

#include <stdio.h>

int main() {
	char str1[10], str2[10];

	printf("문자열을 입력하세요 : ");
	scanf("%s", str1);
	printf("입력한 문자열 : %s \n", str1);

	printf("문자열을 입력하세요 : ");
	scanf("%s", str2);
	printf("입력한 문자열 : %s \n", str2);

	return 0;
}
```

![image](https://github.com/ii200400/IT_Skill_Question/assets/19484971/f367c244-0725-475b-95b6-8c87364cbe17)

공백문자에는 띄어쓰기도 포함되기 때문에 첫 번째 `%s`로 인해 `stdin`이 데이터를 가져올 때는 앞의 `qwer`만 읽어오고 두 번째 `%s`는 버퍼에 남은 `asdf`을 읽어오는 것이다.

### 버퍼를 비우는 방법

버퍼에 남아있는 문자로 인해서 문제가 생기는 상황이 많다. 이를 해결할 수 있는 방법을 살펴보자!

```
/* 15-2 4 버퍼 비우기

Visual Studio 2015 부터는 표준을 따라 fflush가 작동하지 않는다.
*/

#include <stdio.h>

int main() {
	int num;
	char c;

	printf("숫자를 입력하세요 : ");
	scanf("%d", &num);

	// fflush(stdin);
	char gc = getchar();

	printf("문자를 입력하세요 : ");
	scanf("%c", &c);

	printf("gc : %c", gc);
	printf("c : %c", c);

	return 0;
}
```

생각한대로 작동한다!

![image](https://github.com/ii200400/IT_Skill_Question/assets/19484971/bf92483e-34a8-43d7-8e1c-4432e798bdfc)

그런데.. 입력을 조금 다르게 넣으면 아래와 같이 된다.

![image](https://github.com/ii200400/IT_Skill_Question/assets/19484971/8b84acb8-7a12-4e24-bd29-16f3c3e93dcd)

숫자 서식지정자는 위에서 말한 것처럼 문자를 만나면 입력을 종료하기 때문이다. 그래서 `c`에 들어갈 문자를 `gc`가 가져가게 되었다.

### 결론

되도록이면 %c 를 사용하지 말자! 강의에서는 정말로 문자 하나만을 입력받는 프로그램을 만드려면 `scanf` 에서 `%s` 형태로 문자열을 입력 받은 뒤에 맨 앞의 한 문자만 취하는 식으로 만들기를 권장하였다.

### 후기

학교에서 원리도 배웠지만 시간이 흐르면서 원리는 까먹고 외우기만 한 부분이었는데, 다시보니.. 또 까먹을 것 같아서 슬프다. 아하하하하핳

문자열을 가지고 노는 경우는 많지 않아서 재미있기도 했다. (역시 사용자의 입력값은 다이나믹한 것이 항상 새롭다!)

- [15-3. 일로와봐, 문자열(string) - 문자열 지지고 볶기 & 리터럴](./15-3.md)
