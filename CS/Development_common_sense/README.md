# 1-6 개발상식

+ 객체 지향 프로그래밍 (Object Oriented Programming - OOP)


## 객체 지향 프로그래밍 (Object Oriented Programming - OOP)

우리가 실생활에서 쓰는 모든 것을 객체로 취급하고 이러한 객체를 중점으로 프로그래밍하는 방식을 의미한다.   
객체 지향 프로그래밍은 프로그램 구현에 필요한 객체를 파악하고 각각의 객체들의 역할이 무엇인지를 정의하여   
객체들 간의 상호작용을 통해 프로그램을 만드는 것을 말한다.
프로그램을 실재로 구현할 때는 클래스와 인스턴스가 필수적인데 설명은 아래와 같다.

+ 클래스(class)
  특정 객체를 추상화하여 속성(attribute)과 행위(behavior)를 변수와 메서드로 정의한 것.
+ 인스턴스(instance)
  클래스에서 정의한 것을 토대로 실제 메모리상에 할당된 것으로 실제 프로그램에서 사용되는 데이터

객체 지향 프로그래밍은 절차 지향 프로그램과 많이 비교를 하는데 이를 잠깐 살펴보고 객체 지향 프로그램의 특징과 설계 원칙을 살펴보겠다.

### 절차 지향 프로그래밍

절차 지향 프로그래밍은 기능을 중점으로 두는 프로그래밍 방식이다. 즉, 어떤 기능을 어떤 순서로 처리하는가에 초점을 맞춘다.   
상대적으로 단순한 절차 지향 프로그래밍의 특징은 다음과 같다.

+ 특징
  + 하나의 큰 기능을 처리하기 위해 작은 단위의 기능들로 나누어 처리하는 **Top-Down** 방식으로 설계한다.
  + 객체지향 프로그래밍과의 가장 큰 차이점으로 데이터와 함수를 별개로 취급한다.   
    단순히 객체를 사용하지 않는다고 생각하면 된다...
  + 비교적 작은 규모의 작업을 수행하는 함수(function)를 생성한다.
  + 인수(parameter)와 반환값(value)으로 명령을 전달하고 수행한다.
  + 특정 기능을 수행하려면 단순히 그 일을 해주는 메소드를 직접 호출하면 된다. 

### 객체 지향 프로그래밍 vs 절차 지향 프로그래밍

| `객체 지향 프로그래밍` | `절차 지향 프로그래밍` |
| ---------------------- | --------------------- |
| 다양한 기능이 들어가는 대형 프로젝트에 적합하다. | 소형 프로젝트에 적합하다. 작은 기능을 객체별로 나눌면 오히려 복잡해질 수 있기 때문이다. |
| 유지보수가  쉽다. 문제가 되는 객체만 살펴보면 되기 때문이다. | 유지보수가 어렵다. |
| 상대적으로 사람이 이해하기 쉽게 객체로 구별이 되어 분석이 쉽다. | 프로젝트가 크면 클수록 분석이 어렵다. |
| 객체를 계획하고 구성하기 위해서 초기에 들어가는 시간과 노력이 많다. | 단순히 일의 과정만을 순차적으로 구현하면 되기 때문에 초기 비용이 적다. |

객체 지향 프로그래밍과 반대되는 개념으로 생각하는 경우가 있지만 어디까지나 중점이 되는 개념이 다른 것 뿐이며   
객체 지향 또한 절차 지향과 같이 코드가 순차적으로 진행된다.   
개인적으로는 절차 지향으로 코딩을 하다가 너무 복잡해진 코드를 점점 감당하기 어려워져서   
사람이 조금 더 이해하기 쉬운 방식으로 프로그래밍 방식을 고안한 것이 객체지향으로 생각하고 있다.

### 객체 지향 프로그래밍의 특징

1. 추상화(abstraction)
    + 불필요한 정보는 숨기고 필요한 정보들만을 표현함으로써 공통의 속성이나 기능을 묶어 이름을 붙이는 것
    + 객체지향적 관점에서는 클래스를 정의하는 것을 추상화라고 할 수 있다.   
      위의 도형 그리기 예제에서 "Line", "Circle", "Rectangle"을 "Shape"로 묶은 것이 추상화이다.

2. 캡슐화(encapsulation)
    + 실제로 구현되는 부분을 외부에 드러나지 않도록 하여 정보를 은닉하는 것
    + 데이터와 기능을 하나로 묶어(클래스로 만들어) 관리하여 객체가 독립적으로 역할을 수행할 수 있도록 한다.
    + 다른 객체가 임의로 변수나 기능을 바꿀 수 없어 오류 방생 확률을 낮춘다.
    + 내부의 데이터는 외부에서 직접 접근할 수 없고 메소드를 통해야 한다.
    
3. 상속성(inheritance)
    + 하나의 클래스가 가진 특징(함수, 데이터)을 다른 클래스가 그대로 물려받는 것   
      이때, 상속한 클래스는 상위 클래스가 되고 상속받은 클래스는 하위 클래스가 된다.
    + 코드의 재활용성이 높아지며 객체지향 방법의 중요한 기능 중 하나에 속한다.

4. 다형성(polymorphism)
    + 약간 다른 방법으로 동작하는 함수를 동일한 이름으로 호출하는 것
    + 동일한 명령의 해석을 연결된 객체에 의존하는 것
    + 오버라이딩(Overriding), 오버로딩(Overloading)
      + 오버라이딩(Overriding) - 부모클래스의 메소드와 같은 이름을 사용하며 매개변수도 같되 내부 소스를 재정의하는 것
      + 오버로딩(Overloading) - 같은 이름의 함수를 여러 개 정의한 후 매개변수를 다르게 하여 같은 이름을 경우에 따라 호출하여 사용하는 것

5. 동적바인딩(Dynamic Binding)
    + 가상 함수를 호출하는 코드를 컴파일할 때, 바인딩을 실행시간에 결정하는 것.
    + 파생 클래스의 객체에 대해, 기본 클래스의 포인터로 가상 함수가 호출될 때 일어난다.
    + 함수를 호출하면 동적 바인딩을 통해 파생 클래스에 오버라이딩 된 함수가 실행
    + 프로그래밍의 유연성을 높여주며 파생 클래스에서 재정의한 함수의 호출을 보장(다형 개념 실현)


#### 객체지향과 절차지향 도형 그리기 예제

한 블로그에서 도형 그리기 예시로 객체지향과 절차지향의 수행 방식의 차이를 보여주었는데 좋은 예시라고 생각해서 남긴다.   

1. 절차 지향 프로그래밍 도형 그리기 함수
    + void drawLine(Position, Color);
    + void drawCircle(Position, Color);
    + void drawRectangle(Position, Color);
    + 위에 정의된 함수에 위치와 색상 인수를 전달해 원하는 도형 그리기를 실행한다.   
      ex) drawLine(PositionData, ColorData)
    
2. 객체 지향 프로그래밍에서의 객체 선언
    + "Shape" 인터페이스(interface) 선언
      + 속성 : Position, Color, Width, Style ...
      + 메소드 : draw(); move(); ...
    + "Shape" 인터페이스를 상속받은 "Line", "Circle", "Rectangle" 클래스 구현
    + 객체화된 인스턴스의 draw() 메소드를 호출해 각 인스턴스의 도형 그리기를 수행   
      ex) LineObject.draw()

##### 참고

+ http://www.incodom.kr/%EA%B0%9D%EC%B2%B4_%EC%A7%80%ED%96%A5
+ http://www.incodom.kr/%EC%A0%88%EC%B0%A8_%EC%A7%80%ED%96%A5
+ 
