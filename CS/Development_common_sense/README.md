# 1-6 개발상식

+ 객체 지향 프로그래밍 (Object Oriented Programming - OOP)
  + 객체 지향 프로그래밍의 특징
  + 객체 지향 설계 5원칙
  + 객체 지향 프로그래밍 vs 절차 지향 프로그래밍

## 객체 지향 프로그래밍 (Object Oriented Programming - OOP)

우리가 실생활에서 쓰는 모든 것을 객체로 취급하고 이러한 객체를 중점으로 프로그래밍하는 방식을 의미한다.   
객체 지향 프로그래밍은 프로그램 구현에 필요한 객체를 파악하고 각각의 객체들의 역할이 무엇인지를 정의하여   
객체들 간의 상호작용을 통해 프로그램을 만드는 것을 말한다.   
프로그램을 실재로 구현할 때는 클래스와 인스턴스가 필수적이며 이것의 설계를 잘 해야 객체 지향 프로그래밍을 이점을 잘 잡을 수 있다.

+ 클래스(class)   
  특정 객체를 추상화하여 속성(attribute)과 행위(behavior)를 변수와 메서드로 정의한 것.
+ 인스턴스(instance)   
  클래스에서 정의한 것을 토대로 실제 메모리상에 할당된 것으로 실제 프로그램에서 사용되는 데이터

### 객체 지향 프로그래밍의 특징

객체 지향 프로그래밍의 특징은 매우 많지만 그 중에서도 가장 유명하고 대표적인 4가지를 소개하면 다음과 같다.

1. 추상화(Abstraction)
    + 불필요한 정보는 숨기고 필요한 정보들만을 표현함으로써 공통의 속성이나 기능을 묶어 이름을 붙이는 것
    + 객체지향적 관점에서는 클래스를 정의하는 것을 추상화라고 할 수 있다.   
      위의 도형 그리기 예제에서 "Line", "Circle", "Rectangle"을 "Shape"로 묶은 것이 추상화이다.

2. 캡슐화(Encapsulation)
    + 실제로 구현되는 부분을 외부에 드러나지 않도록 하여 정보를 은닉하는 것
    + 데이터와 기능을 하나로 묶어(클래스로 만들어) 관리하여 객체가 독립적으로 역할을 수행할 수 있도록 한다.
    + 다른 객체가 임의로 변수나 기능을 바꿀 수 없어 오류 방생 확률을 낮춘다.
    + 내부의 데이터는 외부에서 직접 접근할 수 없고 메소드를 통해야 한다.
    
3. 상속성(Inheritance)
    + 하나의 클래스가 가진 특징(함수, 데이터)을 다른 클래스가 그대로 물려받는 것   
      이때, 상속한 클래스는 상위 클래스 혹은 부모 클래스가 되고 상속받은 클래스는 하위 클래스 혹은 자식 클래스가 된다.
    + 코드의 재활용성이 높아지며 객체지향 방법의 중요한 기능 중 하나에 속한다.

4. 다형성(Polymorphism)
    + 같은 이름을 가진 요소들(상수, 변수, 식, 오브젝트, 함수, 메소드 등)을 다양한 객체에서 호출할 수 있는 것
    + 오버라이딩(Overriding), 오버로딩(Overloading)이 대표적이다.
      + 오버라이딩(Overriding)    
        자식 클래스에서 부모 클래스의 함수를 재정의하는 것   
        자바와 코틀린에서는 @Override 라는 어노테이션을 사용하여 구현한다.
      + 오버로딩(Overloading)   
        같은 이름의 함수를 매개변수를 다르게 하여 여러 개 정의하여 사용하는 것   
        작성 방법은 [이곳](https://steady-coding.tistory.com/446)을 참고하자.

### 객체 지향 설계 5원칙

이름 그대로 객체 지향 프로그래밍 설계 방법 5가지를 의미한다, 5개 원칙의 머리글자를 따서 'SOLID' 라고도 한다.   
원칙을 지키면서 설계하면, 그 프로그램은 이해하기 쉽고 유지보수 하기 용이하며 논리적일 가능성이 높다.

1. 단일 책임 원칙 (SRP - Single Responsibility Principle)
단일 책임 원칙은 하나의 클래스는 하나의 책임과 역할만 갖도록 한다는 것이다.   
쉽게 말하면 클래스의 추상화를 명확히 하여 기능을 명료하게 정하라는 의미이다.

이를 지키지 않게 되면 객체에 대한 설계를 잘 하지 못했다는 의미로   
어느 클래스에 어느 기능이 있는지 알 수 없어 유지보수가 어렵고 프로그램 분석이 어려워진다.   

2. 개방 폐쇄 원칙(OCP - Open-Closed Principle)
확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다.
상속성을 활용하여 클래스 확장은 용이하게, 하지만 클래스의 캡슐화는 확실하게 하라는 의미이다.
조금 더 간단하게 쓰면 상속이나 기능이 많아질 때마다 변경할 점이 너무 많은 코드는 지양하라는 것

개인적으로는 이해하기 가장 어려운 원칙인데, 가벼운 예시를 글로만 간단히 써보겠다.   
car라는 클래스를 만드는데 wheel은 필수적으로 필요한 변수이다.   
때문에 wheel 변수를 car에 넣겠지만 wheel은 3가지 종류가 있다.   
어떤 wheel이 와도 차는 move 기능을 원활히 수행할 수 있어야 하며 wheel 종류가 더 많아져도 car 클래스의 변경점은 없어야 한다.

여기서 wheel 종류가 많아진다고 car의 기능을 수정해야 한다면 추상화 혹은 캡슐화가 잘 되지 않을 것으로 볼 수도 있다.   

3. 리스코프 치환 원칙(LSP - Liskov Substitution Principle)
상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다.
여기서 상위 타입 객체는 부모 클래스, 하위 타입 객체는 자식 클래스를 의미하며   
상속성을 생각하면 당연한 원칙이기도 하다.

개인적으로는 어떻게 이 원칙이 깨질 수 있는지 궁금하다. 복잡한 객체를 사용한 경험이 없어서 인듯 하다.

4. 인터페이스 분리 원칙(ISP - Interface Segregation Principle)
자신이 사용하지 않는 함수와 의존 관계를 맺지 않는다.   
쉼게 서술하면 기능들을 세분화하여 관리해서 사용하지 않는 기능을 가지지 않도록 해야한다는 의미이다.

간단히 예시를 들어보자면, move라는 클래스에는 fly와 drive라는 기능이 있다고 하자.   
그리고 비행기와 자동차 객체를 의미하는 airPlane 클래스와 car 클래스를 생성할 예정이다.
airPlane 이라는 클래스를 만들 때, move라는 클래스를 상속받으면 활주로운행 기능과 비행기능을 쉽게 넣을 수 있다.   
또한, car 라는 클래스를 만들 때도 move의 drive 기능을 사용하면 편해보인다. 하지만!   
그대로 상속하면 자동차는 날 수 없기 때문에 fly라는 의미없는 기능이 추가되고 만다.   

그러면 어떻게하면 될까?   
간단히 move라는 클래스를 사용하지 않고 fly와 drive 클래스를 따로 만들어서   
airPlane 클래스는 fly와 drive 클래스를 상속하도록 만들고 car 클래스는 drive 클래스만을 상속하도록 만들면 된다.

자연스럽게 기능별로 클래스나 인터페이스가 분리되어 상속이 많아지는 결과로 이어진다.   
이전에 객체지향이 상속의 상속의 상속... 이 겹겹이 쌓여 결국에는 복잡해지는 문제점이 생긴다는 글을 봤는데 이 원칙이 원인인 것 같다.

5. 의존 역전 원칙(DIP - Dependency Inversion Principle)
고수준 모듈은 저수준 모듈의 구현에 의존해서는 안된다.
모듈이 무엇인지 정확히 모르겠지만, 풀이해보면   
잘 바뀌지 않는 객체가 자주 바뀌는 객체를 참고하면 안 된다. 혹은 구체적인 객체가 추상적인 객체에 의존하면 안 된다. 라고 해석된다.

개방 폐쇄 원칙에서 사용하였던 예시와 유사하게 설명하겠다.
car라는 클래스는 commnWheel이라는 클래스를 가진(의존한)다.
겨울이 되어 car는 commnWheel 대신 snowWheel이라는 클래스로 바꾸고 싶어졌다.   
그러면 기존 commnWheel에 대한 코드에 snowWheel에 대한 코드를 추가해야 하는가? 하지만 그렇게 되면 개방 폐쇄 원칙에 위배된다.   
대신 wheel이라는 상위 추상 클래스를 만들어 commnWheel 과 snowWheel에게 상속하여 기본적인 내용을 구성하고   
car 클래스는 wheel이라는 클래스를 변수로 가지도록 만들면 commnWheel 과 snowWheel 어떤 것이 와도 문제가 없다.

의존 역전 원칙에 위배되면 필연적으로 개방 폐쇄 원칙도 위배되는 경우가 많아 의도치 않게 두 원칙의 예시가 같아졌다.
해당 설명은 필자가 직접 위배한 경험이 있기 때문에 뼈 아프게 다가왔다.

<br/>

5가지 원칙에 대해서 정리를 간결하게 해보겠다.

단일 책임 원칙으로 객체의 역할과 기능을 분명히 하고   
개방 폐쇄 원칙으로 객체의 기능 확장에 추가적인 코드가 최소한이 되도록 하며   
리스코프 치환 원칙으로 자식 클래스는 상위 클래스에 대하여 호환성이 있어야 하며   
인터페이스 분리 원칙으로 클래스가 필요한 기능만을 가질 수 있도록 기능을 작게 나눠 관리하며   
의존 역전 원칙으로 객체 간의 관계 혹은 의존이 적절한지 살펴야 한다.   

<br/>

5가지 원칙을 이해하는 대로 적어보았다.   
원칙들과 원칙을 지키지 않는 예시를 살펴보면서 객체지향에 대해서 더 많이 이해할 수 있었던 것 같다.   
그래도 이론을 먼저 보는 사람들이 보기에는 잘 와닿지 않을 것이다, 스스로 위배를 하면서 언칙을 생각하면 금방 이해할 것이라 생각한다.   
또한, **원칙을 지키는 것이 좋지만 객체지향이 모든 방면에서 모든 일을 완벽하게 적용시킬 수는 없는 것 또한 알게 되었다.**

### 절차 지향 프로그래밍

객체 지향 프로그래밍은 절차 지향 프로그램과 많이 비교를 하는데 이를 위해 절차 지향 프로그래밍을 가볍게 살펴보겠다.

절차 지향 프로그래밍은 기능을 중점으로 두는 프로그래밍 방식이다. 즉, 어떤 기능을 어떤 순서로 처리하는가에 초점을 맞춘다.   
상대적으로 단순한 절차 지향 프로그래밍의 특징은 다음과 같다.

+ 특징
  + 하나의 큰 기능을 처리하기 위해 작은 단위의 기능들로 나누어 처리하는 **Top-Down** 방식으로 설계한다.
  + 객체지향 프로그래밍과의 가장 큰 차이점으로 데이터와 함수를 별개로 취급한다.   
    단순히 객체를 사용하지 않는다고 생각하면 된다...
  + 비교적 작은 규모의 작업을 수행하는 함수(function)를 생성한다.
  + 인수(parameter)와 반환값(value)으로 명령을 전달하고 수행한다.
  + 특정 기능을 수행하려면 단순히 그 일을 해주는 메소드를 직접 호출하면 된다. 

### 객체 지향 프로그래밍 vs 절차 지향 프로그래밍

| `객체 지향 프로그래밍` | `절차 지향 프로그래밍` |
| ---------------------- | --------------------- |
| 다양한 기능이 들어가는 대형 프로젝트에 적합하다. | 소형 프로젝트에 적합하다. 작은 기능을 객체별로 나눌면 오히려 복잡해질 수 있기 때문이다. |
| 유지보수가  쉽다. 문제가 되는 객체만 살펴보면 되기 때문이다. | 유지보수가 어렵다. |
| 상대적으로 사람이 이해하기 쉽게 객체로 구별이 되어 분석이 쉽다. | 프로젝트가 크면 클수록 분석이 어렵다. |
| 객체를 계획하고 설계하기 위해서 초기에 들어가는 시간과 노력이 많다. | 단순히 일의 과정만을 순차적으로 구현하면 되기 때문에 초기 비용이 적다. |
| 처리속도가 느리다. | 처리속도가 빠르다. |

객체 지향 프로그래밍과 반대되는 개념으로 생각하는 경우가 있지만 어디까지나 중점이 되는 개념이 다른 것 뿐이며   
객체 지향 또한 절차 지향과 같이 코드가 순차적으로 진행된다.   
개인적으로는 절차 지향으로 코딩을 하다가 너무 복잡해진 코드를 점점 감당하기 어려워져서   
사람이 조금 더 이해하기 쉬운 방식으로 프로그래밍 방식을 고안한 것이 객체지향으로 생각하고 있다.

#### 객체지향과 절차지향 도형 그리기 예제

한 블로그에서 도형 그리기 예시로 객체지향과 절차지향의 수행 방식의 차이를 보여주었는데 좋은 예시라고 생각해서 남긴다.   

1. 절차 지향 프로그래밍 도형 그리기 함수
    + void drawLine(Position, Color);
    + void drawCircle(Position, Color);
    + void drawRectangle(Position, Color);
    + 위에 정의된 함수에 위치와 색상 인수를 전달해 원하는 도형 그리기를 실행한다.   
      ex) drawLine(PositionData, ColorData)
    
2. 객체 지향 프로그래밍에서의 객체 선언
    + "Shape" 인터페이스(interface) 선언
      + 속성 : Position, Color, Width, Style ...
      + 메소드 : draw(); move(); ...
    + "Shape" 인터페이스를 상속받은 "Line", "Circle", "Rectangle" 클래스 구현
    + 객체화된 인스턴스의 draw() 메소드를 호출해 각 인스턴스의 도형 그리기를 수행   
      ex) LineObject.draw()

##### 참고

+ [객체 지향](http://www.incodom.kr/%EA%B0%9D%EC%B2%B4_%EC%A7%80%ED%96%A5)
+ [절차 지향](http://www.incodom.kr/%EC%A0%88%EC%B0%A8_%EC%A7%80%ED%96%A5)
+ [다형성(Polymorphism)이란?](https://steady-coding.tistory.com/446)
+ [객체지향 설계원칙 이해하기](https://western-sky.tistory.com/77)
+ [단일 책임 원칙(SRP)이란?](https://steady-coding.tistory.com/370)
+ [개방 폐쇄 원칙(OCP)이란?](https://steady-coding.tistory.com/378)

## RESTful API

“REpresentational State Transfer” 의 약자인 REST에 ~ful 이라는 형용사형 어미를 붙여 이름이 만들어졌다.   
즉, REST의 기본 원칙을 잘 지킨 api를 RESTful API 이라고 부른다.   

본격적으로 설명하기 앞서 REST와 API에 대한 설명을 먼저 간략하게 진행하고 하겠다.

### REST (REpresentational State Transfer)

월드 와이드 웹(www)과 같은 분산 하이퍼미디어 시스템을 위한 소프트웨어 개발 아키텍처의 한 형식으로   
설계의 중심에 자원(Resource)이 있고 HTTP Method 를 통해 자원을 처리하도록 하는 설계(ROA - Resource Oriented Architecture)를 말한다.   
기본적으로 자원의 이름(자원의 표현)으로 처리 방식을 구분하여 해당 자원의 상태(정보)를 주고 받으며   
웹의 기술과 HTTP 프로토콜을 그대로 활용하기 때문에 웹의 장점을 최대한 활용할 수 있다.

#### REST 구성 요소

1. 자원(Resource): URI   
모든 자원에 고유한 ID가 존재하고, 이 자원은 Server에 존재한다.   
자원을 구별하는 ID는 ‘/groups/:group_id’와 같이 HTTP URI에 포함되어 사용될 수도 있다.   
Client는 URI를 이용해서 자원을 지정하고 해당 자원의 상태(정보)에 대한 조작을 Server에 요청한다.

2. 행위(Verb): HTTP Method   
HTTP 프로토콜의 Method를 사용한다.   
HTTP 프로토콜은 GET, POST, PUT, PATCH, DELETE 와 같은 메서드를 제공한다.

3. 표현(Representation of Resource)   
Client가 자원의 상태(정보)에 대한 조작을 요청하면 Server는 이에 적절한 응답(Representation)을 보낸다.   
REST에서 하나의 자원은 JSON, XML, TEXT, RSS 등 여러 형태의 데이터 형식으로 표현될 수 있다.   
JSON 혹은 XML를 통해 데이터를 주고 받는 것이 일반적이다.

즉, HTTP URI(Uniform Resource Identifier)를 통해 자원(Resource)을 명시하고   
HTTP Method(POST, GET, PUT, PATCH, DELETE)를 통해 해당 자원을 처리(CRUD Operation)하는 것을 의미한다.
+ CRUD Operation
  + Create : 생성(POST)
  + Read : 조회(GET)
  + Update : 수정(PUT, PATCH)
  + Delete : 삭제(DELETE)
  + HEAD: header 정보 조회(HEAD)

### REST 특징

1. Server-Client(서버-클라이언트 구조)   
자원이 있는 쪽이 Server, 자원을 요청하는 쪽이 Client가 된다.
REST Server: API를 제공하고 비즈니스 로직 처리 및 저장을 책임진다.
Client: 사용자 인증이나 context(세션, 로그인 정보) 등을 직접 관리하고 책임진다.
서로 간 의존성이 줄어든다.

2. Stateless(무상태)   
HTTP 프로토콜은 Stateless Protocol이므로 REST 역시 무상태성을 갖는다.
Client의 context를 Server에 저장하지 않는다.
즉, 세션과 쿠키와 같은 context 정보를 신경쓰지 않아도 되므로 구현이 단순해진다.
Server는 각각의 요청을 완전히 별개의 것으로 인식하고 처리한다.
각 API 서버는 Client의 요청만을 단순 처리한다.
즉, 이전 요청이 다음 요청의 처리에 연관되어서는 안된다.
물론 이전 요청이 DB를 수정하여 DB에 의해 바뀌는 것은 허용한다.
Server의 처리 방식에 일관성을 부여하고 부담이 줄어들며, 서비스의 자유도가 높아진다.

3. Cacheable(캐시 처리 가능)
웹 표준 HTTP 프로토콜을 그대로 사용하므로 웹에서 사용하는 기존의 인프라를 그대로 활용할 수 있다.
즉, HTTP가 가진 가장 강력한 특징 중 하나인 캐싱 기능을 적용할 수 있다.
HTTP 프로토콜 표준에서 사용하는 Last-Modified 태그나 E-Tag를 이용하면 캐싱 구현이 가능하다.
대량의 요청을 효율적으로 처리하기 위해 캐시가 요구된다.
캐시 사용을 통해 응답시간이 빨라지고 REST Server 트랜잭션이 발생하지 않기 때문에 전체 응답시간, 성능, 서버의 자원 이용률을 향상시킬 수 있다.

4. Layered System(계층화)
Client는 REST API Server만 호출한다.
REST Server는 다중 계층으로 구성될 수 있다.
API Server는 순수 비즈니스 로직을 수행하고 그 앞단에 보안, 로드밸런싱, 암호화, 사용자 인증 등을 추가하여 구조상의 유연성을 줄 수 있다.
또한 로드밸런싱, 공유 캐시 등을 통해 확장성과 보안성을 향상시킬 수 있다.
PROXY, 게이트웨이 같은 네트워크 기반의 중간 매체를 사용할 수 있다.
Code-On-Demand(optional)
Server로부터 스크립트를 받아서 Client에서 실행한다.
반드시 충족할 필요는 없다.

5. Uniform Interface(인터페이스 일관성)
URI로 지정한 Resource에 대한 조작을 통일되고 한정적인 인터페이스로 수행한다.
HTTP 표준 프로토콜에 따르는 모든 플랫폼에서 사용이 가능하다.
특정 언어나 기술에 종속되지 않는다.
https://gmlwjd9405.github.io/2018/09/21/rest-and-restful.html

### API - Application Programming Interface

    응용 프로그램에서 사용할 수 있도록, 운영 체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 있게 만든 인터페이스를 뜻한다.
    -wikipedia-
    
api는 여러곳에서 쓰고 있기 때문에 기본적으로는 위의 정의가 더 정확하나,   
RESTful API에서의 api는 '애플리케이션 소프트웨어를 구축하고 통합하기 위한 정의 및 프로토콜 세트'라고 생각하면 된다.   
여기서 '애플리케이션 소프트웨어'는 PC 앱도, 웹도, 핸드폰 앱도 될 수 있으며   
'프로토콜'은 카메라나 진동 센서 같은 기능에 관한 것일수도, 통신을 위한 것일 수도 있다.

즉, 다양한 장치에서 다양한 언어로 프로그래밍하여도 일관적인 결과를 얻을 수 있도록 큰 틀(인터페이스)을 만들어주는 역할을 한다.



##### 참고

+ [[Network] REST란? REST API란? RESTful이란?](https://gmlwjd9405.github.io/2018/09/21/rest-and-restful.html)
+ 



