# 1-6 개발상식

+ 객체 지향 프로그래밍 (Object Oriented Programming - OOP)
  + 객체 지향 프로그래밍의 특징
  + 객체 지향 설계 5원칙
  + 객체 지향 프로그래밍 vs 절차 지향 프로그래밍

## 객체 지향 프로그래밍 (Object Oriented Programming - OOP)

우리가 실생활에서 쓰는 모든 것을 객체로 취급하고 이러한 객체를 중점으로 프로그래밍하는 방식을 의미한다.   
객체 지향 프로그래밍은 프로그램 구현에 필요한 객체를 파악하고 각각의 객체들의 역할이 무엇인지를 정의하여   
객체들 간의 상호작용을 통해 프로그램을 만드는 것을 말한다.   
프로그램을 실재로 구현할 때는 클래스와 인스턴스가 필수적이며 이것의 설계를 잘 해야 객체 지향 프로그래밍을 이점을 잘 잡을 수 있다.

+ 클래스(class)   
  특정 객체를 추상화하여 속성(attribute)과 행위(behavior)를 변수와 메서드로 정의한 것.
+ 인스턴스(instance)   
  클래스에서 정의한 것을 토대로 실제 메모리상에 할당된 것으로 실제 프로그램에서 사용되는 데이터

### 객체 지향 프로그래밍의 특징

객체 지향 프로그래밍의 특징은 매우 많지만 그 중에서도 가장 유명하고 대표적인 4가지를 소개하면 다음과 같다.

1. 추상화(Abstraction)
    + 불필요한 정보는 숨기고 필요한 정보들만을 표현함으로써 공통의 속성이나 기능을 묶어 이름을 붙이는 것
    + 객체지향적 관점에서는 클래스를 정의하는 것을 추상화라고 할 수 있다.   
      위의 도형 그리기 예제에서 "Line", "Circle", "Rectangle"을 "Shape"로 묶은 것이 추상화이다.

2. 캡슐화(Encapsulation)
    + 실제로 구현되는 부분을 외부에 드러나지 않도록 하여 정보를 은닉하는 것
    + 데이터와 기능을 하나로 묶어(클래스로 만들어) 관리하여 객체가 독립적으로 역할을 수행할 수 있도록 한다.
    + 다른 객체가 임의로 변수나 기능을 바꿀 수 없어 오류 방생 확률을 낮춘다.
    + 내부의 데이터는 외부에서 직접 접근할 수 없고 메소드를 통해야 한다.
    
3. 상속성(Inheritance)
    + 하나의 클래스가 가진 특징(함수, 데이터)을 다른 클래스가 그대로 물려받는 것   
      이때, 상속한 클래스는 상위 클래스 혹은 부모 클래스가 되고 상속받은 클래스는 하위 클래스 혹은 자식 클래스가 된다.
    + 코드의 재활용성이 높아지며 객체지향 방법의 중요한 기능 중 하나에 속한다.

4. 다형성(Polymorphism)
    + 같은 이름을 가진 요소들(상수, 변수, 식, 오브젝트, 함수, 메소드 등)을 다양한 객체에서 호출할 수 있는 것
    + 오버라이딩(Overriding), 오버로딩(Overloading)이 대표적이다.
      + 오버라이딩(Overriding)    
        자식 클래스에서 부모 클래스의 함수를 재정의하는 것   
        자바와 코틀린에서는 @Override 라는 어노테이션을 사용하여 구현한다.
      + 오버로딩(Overloading)   
        같은 이름의 함수를 매개변수를 다르게 하여 여러 개 정의하여 사용하는 것   
        작성 방법은 [이곳](https://steady-coding.tistory.com/446)을 참고하자.

### 객체 지향 설계 5원칙

이름 그대로 객체 지향 프로그래밍 설계 방법 5가지를 의미한다, 5개 원칙의 머리글자를 따서 'SOLID' 라고도 한다.   
원칙을 지키면서 설계하면, 그 프로그램은 이해하기 쉽고 유지보수 하기 용이하며 논리적일 가능성이 높다.

1. 단일 책임 원칙 (SRP - Single Responsibility Principle)
단일 책임 원칙은 하나의 클래스는 하나의 책임과 역할만 갖도록 한다는 것이다.   
쉽게 말하면 클래스의 추상화를 명확히 하여 기능을 명료하게 정하라는 의미이다.

이를 지키지 않게 되면 객체에 대한 설계를 잘 하지 못했다는 의미로   
어느 클래스에 어느 기능이 있는지 알 수 없어 유지보수가 어렵고 프로그램 분석이 어려워진다.   

2. 개방 폐쇄 원칙(OCP - Open-Closed Principle)
확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다.
상속성을 활용하여 클래스 확장은 용이하게, 하지만 클래스의 캡슐화는 확실하게 하라는 의미이다.
조금 더 간단하게 쓰면 상속이나 기능이 많아질 때마다 변경할 점이 너무 많은 코드는 지양하라는 것

개인적으로는 이해하기 가장 어려운 원칙인데, 가벼운 예시를 글로만 간단히 써보겠다.   
car라는 클래스를 만드는데 wheel은 필수적으로 필요한 변수이다.   
때문에 wheel 변수를 car에 넣겠지만 wheel은 3가지 종류가 있다.   
어떤 wheel이 와도 차는 move 기능을 원활히 수행할 수 있어야 하며 wheel 종류가 더 많아져도 car 클래스의 변경점은 없어야 한다.

여기서 wheel 종류가 많아진다고 car의 기능을 수정해야 한다면 추상화 혹은 캡슐화가 잘 되지 않을 것으로 볼 수도 있다.   

3. 리스코프 치환 원칙(LSP - Liskov Substitution Principle)
상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다.
여기서 상위 타입 객체는 부모 클래스, 하위 타입 객체는 자식 클래스를 의미하며   
상속성을 생각하면 당연한 원칙이기도 하다.

개인적으로는 어떻게 이 원칙이 깨질 수 있는지 궁금하다. 복잡한 객체를 사용한 경험이 없어서 인듯 하다.

4. 인터페이스 분리 원칙(ISP - Interface Segregation Principle)
자신이 사용하지 않는 함수와 의존 관계를 맺지 않는다.   
쉼게 서술하면 기능들을 세분화하여 관리해서 사용하지 않는 기능을 가지지 않도록 해야한다는 의미이다.

간단히 예시를 들어보자면, move라는 클래스에는 fly와 drive라는 기능이 있다고 하자.   
그리고 비행기와 자동차 객체를 의미하는 airPlane 클래스와 car 클래스를 생성할 예정이다.
airPlane 이라는 클래스를 만들 때, move라는 클래스를 상속받으면 활주로운행 기능과 비행기능을 쉽게 넣을 수 있다.   
또한, car 라는 클래스를 만들 때도 move의 drive 기능을 사용하면 편해보인다. 하지만!   
그대로 상속하면 자동차는 날 수 없기 때문에 fly라는 의미없는 기능이 추가되고 만다.   

그러면 어떻게하면 될까?   
간단히 move라는 클래스를 사용하지 않고 fly와 drive 클래스를 따로 만들어서   
airPlane 클래스는 fly와 drive 클래스를 상속하도록 만들고 car 클래스는 drive 클래스만을 상속하도록 만들면 된다.

자연스럽게 기능별로 클래스나 인터페이스가 분리되어 상속이 많아지는 결과로 이어진다.   
이전에 객체지향이 상속의 상속의 상속... 이 겹겹이 쌓여 결국에는 복잡해지는 문제점이 생긴다는 글을 봤는데 이 원칙이 원인인 것 같다.

5. 의존 역전 원칙(DIP - Dependency Inversion Principle)
고수준 모듈은 저수준 모듈의 구현에 의존해서는 안된다.
모듈이 무엇인지 정확히 모르겠지만, 풀이해보면   
잘 바뀌지 않는 객체가 자주 바뀌는 객체를 참고하면 안 된다. 혹은 구체적인 객체가 추상적인 객체에 의존하면 안 된다. 라고 해석된다.

개방 폐쇄 원칙에서 사용하였던 예시와 유사하게 설명하겠다.
car라는 클래스는 commnWheel이라는 클래스를 가진(의존한)다.
겨울이 되어 car는 commnWheel 대신 snowWheel이라는 클래스로 바꾸고 싶어졌다.   
그러면 기존 commnWheel에 대한 코드에 snowWheel에 대한 코드를 추가해야 하는가? 하지만 그렇게 되면 개방 폐쇄 원칙에 위배된다.   
대신 wheel이라는 상위 추상 클래스를 만들어 commnWheel 과 snowWheel에게 상속하여 기본적인 내용을 구성하고   
car 클래스는 wheel이라는 클래스를 변수로 가지도록 만들면 commnWheel 과 snowWheel 어떤 것이 와도 문제가 없다.

의존 역전 원칙에 위배되면 필연적으로 개방 폐쇄 원칙도 위배되는 경우가 많아 의도치 않게 두 원칙의 예시가 같아졌다.
해당 설명은 필자가 직접 위배한 경험이 있기 때문에 뼈 아프게 다가왔다.

<br/>

5가지 원칙에 대해서 정리를 간결하게 해보겠다.

단일 책임 원칙으로 객체의 역할과 기능을 분명히 하고   
개방 폐쇄 원칙으로 객체의 기능 확장에 추가적인 코드가 최소한이 되도록 하며   
리스코프 치환 원칙으로 자식 클래스는 상위 클래스에 대하여 호환성이 있어야 하며   
인터페이스 분리 원칙으로 클래스가 필요한 기능만을 가질 수 있도록 기능을 작게 나눠 관리하며   
의존 역전 원칙으로 객체 간의 관계 혹은 의존이 적절한지 살펴야 한다.   

<br/>

5가지 원칙을 이해하는 대로 적어보았다.   
원칙들과 원칙을 지키지 않는 예시를 살펴보면서 객체지향에 대해서 더 많이 이해할 수 있었던 것 같다.   
그래도 이론을 먼저 보는 사람들이 보기에는 잘 와닿지 않을 것이다, 스스로 위배를 하면서 언칙을 생각하면 금방 이해할 것이라 생각한다.   
또한, **원칙을 지키는 것이 좋지만 객체지향이 모든 방면에서 모든 일을 완벽하게 적용시킬 수는 없는 것 또한 알게 되었다.**

### 절차 지향 프로그래밍

객체 지향 프로그래밍은 절차 지향 프로그램과 많이 비교를 하는데 이를 위해 절차 지향 프로그래밍을 가볍게 살펴보겠다.

절차 지향 프로그래밍은 기능을 중점으로 두는 프로그래밍 방식이다. 즉, 어떤 기능을 어떤 순서로 처리하는가에 초점을 맞춘다.   
상대적으로 단순한 절차 지향 프로그래밍의 특징은 다음과 같다.

+ 특징
  + 하나의 큰 기능을 처리하기 위해 작은 단위의 기능들로 나누어 처리하는 **Top-Down** 방식으로 설계한다.
  + 객체지향 프로그래밍과의 가장 큰 차이점으로 데이터와 함수를 별개로 취급한다.   
    단순히 객체를 사용하지 않는다고 생각하면 된다...
  + 비교적 작은 규모의 작업을 수행하는 함수(function)를 생성한다.
  + 인수(parameter)와 반환값(value)으로 명령을 전달하고 수행한다.
  + 특정 기능을 수행하려면 단순히 그 일을 해주는 메소드를 직접 호출하면 된다. 

### 객체 지향 프로그래밍 vs 절차 지향 프로그래밍

| `객체 지향 프로그래밍` | `절차 지향 프로그래밍` |
| ---------------------- | --------------------- |
| 다양한 기능이 들어가는 대형 프로젝트에 적합하다. | 소형 프로젝트에 적합하다. 작은 기능을 객체별로 나눌면 오히려 복잡해질 수 있기 때문이다. |
| 유지보수가  쉽다. 문제가 되는 객체만 살펴보면 되기 때문이다. | 유지보수가 어렵다. |
| 상대적으로 사람이 이해하기 쉽게 객체로 구별이 되어 분석이 쉽다. | 프로젝트가 크면 클수록 분석이 어렵다. |
| 객체를 계획하고 설계하기 위해서 초기에 들어가는 시간과 노력이 많다. | 단순히 일의 과정만을 순차적으로 구현하면 되기 때문에 초기 비용이 적다. |
| 처리속도가 느리다. | 처리속도가 빠르다. |

객체 지향 프로그래밍과 반대되는 개념으로 생각하는 경우가 있지만 어디까지나 중점이 되는 개념이 다른 것 뿐이며   
객체 지향 또한 절차 지향과 같이 코드가 순차적으로 진행된다.   
개인적으로는 절차 지향으로 코딩을 하다가 너무 복잡해진 코드를 점점 감당하기 어려워져서   
사람이 조금 더 이해하기 쉬운 방식으로 프로그래밍 방식을 고안한 것이 객체지향으로 생각하고 있다.

#### 객체지향과 절차지향 도형 그리기 예제

한 블로그에서 도형 그리기 예시로 객체지향과 절차지향의 수행 방식의 차이를 보여주었는데 좋은 예시라고 생각해서 남긴다.   

1. 절차 지향 프로그래밍 도형 그리기 함수
    + void drawLine(Position, Color);
    + void drawCircle(Position, Color);
    + void drawRectangle(Position, Color);
    + 위에 정의된 함수에 위치와 색상 인수를 전달해 원하는 도형 그리기를 실행한다.   
      ex) drawLine(PositionData, ColorData)
    
2. 객체 지향 프로그래밍에서의 객체 선언
    + "Shape" 인터페이스(interface) 선언
      + 속성 : Position, Color, Width, Style ...
      + 메소드 : draw(); move(); ...
    + "Shape" 인터페이스를 상속받은 "Line", "Circle", "Rectangle" 클래스 구현
    + 객체화된 인스턴스의 draw() 메소드를 호출해 각 인스턴스의 도형 그리기를 수행   
      ex) LineObject.draw()

##### 참고

객체지향에 대해서 자세히 아려다가 머리털 빠지는 줄..

+ [객체 지향](http://www.incodom.kr/%EA%B0%9D%EC%B2%B4_%EC%A7%80%ED%96%A5)
+ [절차 지향](http://www.incodom.kr/%EC%A0%88%EC%B0%A8_%EC%A7%80%ED%96%A5)
+ [다형성(Polymorphism)이란?](https://steady-coding.tistory.com/446)
+ [객체지향 설계원칙 이해하기](https://western-sky.tistory.com/77)
+ [단일 책임 원칙(SRP)이란?](https://steady-coding.tistory.com/370)
+ [개방 폐쇄 원칙(OCP)이란?](https://steady-coding.tistory.com/378)
