# 1-3. 컴퓨터 구조와 운영체제
+ OS 개요
+ 프로세스와 스레드
  + 프로세스
  + 스레드
  + 멀티 프로세스와 멀티 스레드
+ 프로세스 동기화
  + 동기 / 비동기
+ CPU 스캐줄링
+ 메모리 관리 전략
+ 가상 메모리

*****

## OS란?
사용자에게 편리한 인터페이스 환경을 제공하고, 컴퓨터 시스템의 자원을 효율적으로 관리하는 시스템 소프트웨어\
사용자와 하드웨어 사이에서 중재자 역할을 한다. 대표적으로 마이크로소프트 윈도우, 맥 OS X, 리눅스가 있다.

컴퓨터 시스템 하드웨어 및 소프트웨어 자원을 여러 사용자에게 효율적 할당, 관리, 보호하며\
제어 프로그램으로서 사용자 프로그램의 오류나 잘못된 자원 사용을 감시하고\
입출력 장치 등의 자원에 대한 연산과 제어를 관리한다.

## 프로세스와 스레드
### 프로세스
프로세스는 프로그램의 인스턴스로 운영체제에서 가장 기본적인 실행 단위이다.\
각 프로세스는 메모리와 일정한 상태 주기를 가진다.

#### 메모리 영역

프로세스는 어떤 프로그램을 실행하느냐에 따라 다르지만 일반적으로\
스택, 힙, 데이터 등의 메모리 영역이 있다.\
**스택 영역**은 지역변수나 함수의 매개변수와 같은 데이터의 메모리를 할당에 관여하고\
**힙 영역**은 동적 메모리 할당에 관여한다.

<img src="../image/1.3%20Process1.png" width="20%" height="20%">

#### 상태 주기
프로세스는 보통 5가지의 상태를 가진다. \
(프로세스를 유지할 메모리가 부족할 경우 추가로 2가지의 상태를 더 가지게 된다.)\

<img src="../image/1.3%20Process2.png">

사진에 나온 용어에 대한 설명
+ 생성(create) : 프로세스가 메모리를 가지고 운영체제는 해당 프로세스의 PCB를 가지게 된다. (PCB 설명은 바로 아래)
+ 준비(ready) : 프로세스가 CPU를 할당받기 위하여 기다리는 상태
+ 실행(running) : 프로세스가 CPU를 할당 받아서 작업을 하고있는 상태
+ 대기(waiting) : 입출력 혹은 이벤트로 인해 대기하고 있는 상태
+ 종료(terminated) : 프로그램이 종료되어 프로세스의 메모리와 대응되는 PCB가 반환된다.(그림에서는 완료라고 쓰여있다.)
+ 보류 대기 : 대기 상태에서 스와핑으로 프로세스의 메모리가 해제된 상태, 입출력이나 이벤트가 끝나면 보류 준비상태로 바뀐다.
+ 보류 준비 : 스와핑으로 프로세스의 메모리가 해제된 상태, 메모리에 여유가 다시 생기면 다시 메모리를 할당 받는다.
  + 스와핑(Swapping) : 프로세스의 일부나 전체를 메모리에서 보조기억장치로 옮겨놓는 방법
+ 디스패치 : CPU 스케줄러에 의해 선정된 프로세스가 실행되는 것 (아래의 CPU 스캐줄링 참고)
+ 인터럽트 : 예기치 않은 상황이 발생하여 현재 실행중인 작업을 즉시 중단하고 준비 상태로 바꾸는 것\
CPU는 이후 문제 상황을 우선 처리한 후 다시 실행중이던 작업을 불러 처리한다.
+ 타임아웃 : 주어진 시간 내로 수행이 완료되지 않아서 프로세스를 준비 상태로 되돌리는 것

#### PCB(Process Control Block)

프로세스가 각자 메모리를 가지는 것 처럼\
운영체제도 프로세스들을 관리하기 위하여 PCB라는 별도의 자료구조를 가진다.

운영체제는 프로세스 생성과 동시에 해당 프로세스와 대응하는 고유한 PCB를 생성한다.\
프로세스가 작업을 중단할 필요가 있을 때 진행 중인 작업을 저장하고 가지고 있던 자원을 반환한다.\
여기서 PCB가 프로세스의 작업을 저장하게 된다.\
중단 되었던 프로세스가 다시 작업을 시작할 때 PCB에 저장되어있던 내용을 불러와 다시 작업을 시작할 수 있도록 한다.

때문에 PCB는 프로세스에 대한 중요한 정보를 저장하고 있다.
  + 프로세스 식별자(Process ID, PID) : 프로세스 식별번호
  + 프로세스 상태 : 생성, 준비, 실행, 대기, 종료 등의 상태를 저장
  + 프로그램 카운터 : 프로세스가 다음에 실행할 명령어의 주소
  + CPU 레지스터
  + CPU 스케쥴링 정보 : 프로세스의 우선순위, 스케줄 큐에 대한 포인터 등 (아래의 CPU 스캐줄링 참고)
  + 메모리 관리 정보 : 페이지 테이블 또는 세그먼트 테이블 등과 같은 정보를 포함 (아래의 메모리 관리 전략 참고)
  + 입출력 상태 정보 : 프로세스에 할당된 입출력 장치들과 열린 파일 목록
  + 어카운팅 정보 : 사용된 CPU 시간, 시간제한, 계정번호 등

*****

### 쓰레드
프로세스의 실행 단위\
각 쓰레드는 독립적인 작업 수행을 위해 고유의 PC 레지스터와 스택 영역을 가진다.\
그리고 모든 쓰레드는 서로간의 통신을 위해서 힙 영역을 공유한다.\

### 멀티 프로세스와 멀티 스레드
#### 멀티 프로세스
똑같은 프로세스를 여러개 만들어 한번에 여러 작업을 수행할 수 있도록 하는 것\
(마치 졸린데 밥은 먹고 싶을 때 분신을 만들어 한명은 자고 다른 한명은 밥을 먹는 방법과 같다.)

+ 장점
  + 하나의 프로세스가 죽더라도 다른 프로세스에는 영향을 끼치지 않고 정상적으로 수행된다
  
+ 단점
  + 연산량이 많고 메모리 공간이 많이 소비된다.
  + 프로세스간 통신이 스레드에 비하여 느리다.

#### 멀티 스레딩
하나의 프로세스를 여러 실행 단위로 나누어 여러 스레드가 나눠 맡아 한번에 여러 작업을 수행하는 것\
(마치 음악을 들으면서 친구와 이야기하는 것과 같다. 단, 물을 마시면서 숨쉬는 것과 같은 행위는 불가능하다.)

+ 장점
  + 메모리 공간과 시스템 자원 소모가 줄어든다.
  + 스레드 간의 통신은 공유 영역인 힙 영역을 이용하기 때문에 비교적 간단하며 빠르다.
  
+ 단점
  + 공유되는 영역인 힙 영역에 대한 동기화 작업이 필요하다.
  + 오류로 인해 하나의 스레드가 종료되면 전체 스레드가 종료될 수 있다.

## 프로세스 동기화
멀티 프로세스에서 프로세스들이 동일한 자원에 동시에 접근하여 각자 다른 값으로 쓰려는 상황을 제어하기 위해서\
하나의 자원을 한 순간에 하나의 프로세스만이 이용하도록 제어하는 것을 의미한다.\
이것이 없다면 하나의 값이 각 프로세스마다 다를수도 있다.

### 동기 / 비동기
앞의 작업이 끝나야지만 뒤의 작업이 시작되는 작업 구조를 동기\
앞의 작업과 뒤의 작업이 동시에 시작되고 어느 작업이 먼저 끝날지 알 수 없는 작업 구조를 비동기라고 한다.\

<img src="../image/1.3%20Sync1.png">

### Critical Section(임계영역)
공유 자원(공유하는 변수나 파일 등)에 접근하는 작업을 실행하는 코드 영역

+ 임계영역에서 

## CPU 스케줄링
스케줄링은 다중 프로그래밍(CPU작업과 입출력 작업을 병행하는 것)을 가능하게 하는 운영 체제의 동작 기법이다.\
즉, 운영체제가 어떤 자원을 어떤 프로세스들에게 할당할지 결정하는 것을 의미한다.

그 중에서도 CPU를 사용하려고 하는 프로세스들 사이의 우선순위를 관리하는 스케줄링을 CPU스케줄링이라고 한다.

+ CPU 스케줄링 종류
  + 비선점 프로세스 스케줄링 : 프로세스가 CPU를 할당받으면 자발적으로 중지될 때까지 계속 실행되도록 보장한다.
    + FCFS 스케줄링(First Come First Served Scheduling)
    + SJF 스케줄링(Shortest Job First Scheduling)
  + 선점 프로세스 스케줄링 : 프로세스가 CPU를 할당받아 실행 중인 프로세스를 중지하고 CPU를 강제로 점유할 수 있다.
    + SRTF 스케줄링(Shortest Remaining-Time First Scheduling)
    + RR 스케줄링(Round Robin Scheduling)

### FCFS(First Come First Served)
CPU를 먼저 요청한 프로세스가 먼저 CPU를 배정받는 비선점 스케줄링 방법

+ 장점
  + 구현이 가장 간단하고 처리 순서가 명확하다.

+ 단점
  + Convoy Effect(소요시간이 긴 프로세스가 먼저 도달하여 효율성을 낮추는 현상)가 생길 수 있다. 
  

### SJF(Shortest Job First) & SRTF(Shortest Remaining time First)
다른 프로세스가 먼저 도착했어도 CPU burst time(처리시간)이 짧은 프로세스에게 먼저 CPU를 할당해주는 스케줄링 방법\
비선점 스케줄러이면 SJF(Shortest Job First), 선점형 스케줄러이면 SRTF(Shortest Remaining time First)이라고 부른다.

현재 수행중인 프로세스의 남은 burst time 보다 더 짧은 CPU burst time 을 가지는 새로운 프로세스가 도착하면\
SJF는 도착하면 대기 큐 head 부분에 새로운 프로세스를 대기시키고\
SRTF는 수행중인 프로세스에게서 CPU를 빼앗아 새로운 프로세스에게 할당해준다.

+ 장점
  + 평균 대기 시간이 가장 짧게 나오는 방법이다.
  
+ 단점
  + Starvation(CPU 사용시간이 긴 프로세스들이 영원히 CPU 할당을 못 받는 상황)이 생길 수 있다.
    + Starvation 해결방법 - Aging\
    대기하고있는 프로세스에 나이를 부여하여 처리시간이 긴 프로세스여도 기다린 시간이 길면 자원을 할당받을 수 있도록 한다.
  + (SRTF만 해당) 새로운 프로세스가 도달할 때마다 스케줄링을 다시하기 때문에 CPU burst time(CPU 사용시간)을 측정할 수가 없다.

### Round Robin
각 프로세스에게 같은 할당 시간(Time Quantum)를 설정하여\
CPU를 점유한 프로세스가 할당 시간을 지나면 선점당하고 프로세스 대기열의 제일 뒤에 가서 다시 줄을 선도록 하는 선점 스케줄링이다.

+ 장점
  + CPU 사용시간이 랜덤한 프로세스들이 섞여있을 경우에 효율적
  + Response time(응답 시간)이 빨라진다.
  + 프로세스가 CPU를 사용하는 만큼 기다리는 시간도 증가한다. (꽤 공정한 스케줄링이다.)
  
+ 단점
  + 설정한 time quantum이 너무 커지면 FCFS와 다를바가 없어진다.
  + 설정한 time quantum이 너무 작으면 잦은 인터럽트 요청으로 인한 Context Switching에 과부화(Overhead)가 발생할 수 있다.
    + Context Switching : 인터럽트 요청에 의해 기존 프로세스를 PCB에 저장하고 다음 프로세스의 상태와 레지스터 값으로 교체하는 작업

