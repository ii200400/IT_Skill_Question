# 1-1. 자료구조
+ Array and List
+ Stack and Queue
+ Graph
+ Tree
+ heap
+ Hash

*****

## 자료구조의 필요성

    전산학에서 자료를 효율적으로 이용할 수 있도록 컴퓨터에 저장하는 방법이다. 
    신중히 선택한 자료구조는 보다 효율적인 알고리즘을 사용할 수 있게 한다. 
    이러한 자료구조의 선택문제는 대개 추상적 자료구조의 선택으로부터 시작하는 경우가 많다. 
    효과적으로 설계된 자료구조는 실행시간 혹은 메모리 용량 등의 자원을 최소한으로 사용하면서 연산을 수행하도록 한다. 
    - 위키백과 -

즉, 제한된 컴퓨터 자원에서 최대한의 효율을 뽑기 위해서 만들어진 선조들의 노오력의 산물이라는 것이다.\
cpu와 메모리가 끔찍할 정도로 강력해진 현재에 와서는 그 필요성이 많이 줄어들었지만 여전히 컴퓨터에서 너무나도 중요한 내용이다.\
같은 문제를 풀어도 자료구조를 아는 사람이 모르는 사람보다 더 짧은 코딩으로 더 빠른 알고리즘을 만드는 경우가 많으며\
아무리 cpu와 메모리가 강력해진다 하더라도 그만큼 사람들이 더 어려운 문제를(빅데이터, AI 등) 컴퓨터를 활용하여 처리하기 때문이다.

코드 구현부분은 제외하였다. 페이지가 너무 길어지고 아니라 구현방법도 사람마다 다르다.\
필자는 개인적으로 알고리즘을 코딩테스트가 가능한 사이트에서 알고리즘을 먼저 공부하고 자료구조를 공부하는 것을 추천한다.\
여기에 서술할 자료구조 정도는 코통 코딩테스트에서 못해도 한번씩은 다루며 \
코딩을 하는 과정에서 자료구조를 자연스럽게 습득하는 경우가 많기 때문이다.


**<code>꼭 자료구조 종류의 특징과 유사한 자료구조 간의 차이점을 중심으로 읽고
다른 카테고리(DB, 네트워크 등)의 기본이 됨을 기억하자!</code>**

*****

## Array and List

+ 시작하기 전에..

Array and List는 가장 흔하게 볼 수 있는 순차적(선형) 자료구조이다. \
그런데 이 두 자료구조의 이름 중 하나(ArrayList)에 의아함을 느껴 깊이 알아보게 되었다.

인터넷에서 Array라고 쓰이는 것은 일반적으로 ArrayList이다. 나는 이것을 구분해서 서술할 것이다.\
면접에서 배열과 연결 리스트의 차이점을 서술하라고 하면 이 페이지의 ArrayList와 LinkedList의 차이를 설명하라는 것과 같다.

혼란을 줄이기 위해서 대표적인 차이점을 먼저 설명하자면\
Array는 원소의 값이 null값을 가질 수 있고\
ArrayList는 원소의 값이 null값을 가질 수 없으며\
LinkedList는 원소의 값이 null값을 가질 수 없으면서 인덱스 대신 포인터를 가지는 자료구조이다.\
차이점을 잘 설명해준 [opentutorials](https://opentutorials.org/module/1335/8636)에게 감사하다.

### Array

+ 설명

랜덤 접근이 가능한 순차적 자료구조이다.\
**원소를 삭제하더라도 그 자리는 다른 원소가 차지하지 못한다. 빈 장소를 그대로 방치한다.**

+ 특징

1. 논리적 저장 순서와 물리적 저장 순서가 일치(index)하는 순차적인 자료구조이다. 
2. 위의 이유로 index를 사용하여 O(1)에 원하는 원소로 접근이 가능하다. \
  random access가 가능하다고 한다.
3. 원소의 삭제, 삽입이 O(1)에 끝난다.
4. 마지막 자리에만 원소를 추가할 수 있다.
5. 원소를 삭제할 때마다 빈 메모리가 생기기 때문에 메모리를 효율적으로 사용하지 못 한다.
6. 재할당을 하지 않는 이상 최대 원소의 갯수는 제한적이다.

+ 예시

순서대로 10, 20, 30, 40, 50을 Array에 넣은 후 40을 삭제하면 다음의 그림이 된다.
![Array1](../image/1.1%20Array1.jpg)

### ArrayList

+ 설명

랜덤 접근이 가능한 순차적 자료구조이다.\
Array에서 null 값을 가지는 원소를 허용하지 않는 방법이다.\
**Array가 아니라 List의 한 종류이다**\
자바 기준으로 List는 인터페이스이고 ArrayList, LinkedList 들은 List에 상속된 클래스들이라고 한다.

+ 특징 

1. 논리적 저장 순서와 물리적 저장 순서가 일치하는 순차적인 자료구조이다. 
2. index를 사용하여 O(1)에 원하는 원소로 접근이 가능하다. 
3. 빈 부분이 없어야 하기 때문에 한 원소를 삭제하면 그 자리를 뒤의 원소들이 한 칸씩 앞으로 와서 매꾸어 주어야 한다. \
  이때 O(n)의 시간이 소모된다. (삽입도 마찬가지로 한 요소가 들어갈 자리를 만들기 위해 원소들이 한 칸씩 뒤로 빠져야 해서 같은 시간이 소모된다.)
2. 재할당을 하지 않는 이상 최대 원소의 갯수는 제한적이다.

+ 예시 사진

순서대로 10, 20, 30, 40, 50을 ArrayList에 넣은 후 40을 삭제하면 다음의 그림이 된다.
![ArrayList1](../image/1.1%20ArrayList1.png)

### LinkedList (연결리스트)

+ 용어
1. 노드(node) / 버텍스(vertex) : LinkedList의 원소를 부를 때 쓰이는 용어
1. 데이터(Data) : 노드의 값을 저장하는 부분이다. 보통 변수명을 **value**로 한다.
1. 포인터 / 링크(Link) : 동적 할당의 포인터와 같은 의미, 다른 노드의 주소를 저장한다. 보통 변수명을 **next**로 한다.
1. 헤드(Head) : 첫 노드를 가리키는 **포인터**. first라고 표현하기도 한다.
1. 테일(Tail) : 마지막 **노드**를 의미한다. end라고 표현하기도 한다.

+ 설명

**랜덤 접근이 불가능한** 순차적 자료구조이다.\
연결리스트는 노드(node) 혹은 버텍스(vertex)라고 불리는 것들로 구성되어 있다.\
노드는 저장할 값(데이터)과 다음 노드를 가리키는 포인터(링크)로 이루어져 있다.\
연결리스트의 헤드(Head)를 시작으로 각 노드의 포인터를 사용하여리스트를 순회할 수 있게 한다.\
**트리(Tree)와 그래프(Graph)의 기본 자료형이다.**

+ 특징

1. 각 노드의 저장 위치는 관련된 노드의 포인터를 통해 알 수 있다.\
  즉, n 번째 원소는 n-1번의 포인트를 찾아가야 하므로 O(n)의 탐색시간이 걸린다.
2. 삭제나 삽입 자체만 생각하면 연관된 노드의 포인터의 값만 바꿔주면 되므로 O(1)이 걸린다.\
  하지만 삭제나 삽입할 위치를 탐색하는 것이 위에서 말한데로 O(n)의 시간이 걸리므로 결과적으로는 O(n)의 시간이 걸린다.
3. 노드를 동적으로 추가, 삭제할 수 있다. (메모리 영역 중 힙(heap)영역이 충분하다면..)

+ 예시 사진

순서대로 10, 20, 30, 40를 LinkedList에 넣었을 때 다음의 그림이 된다.
![LinkedList1](../image/1.1%20LinkedList1.png)

+ 종류
1. Singly Linked List\
가장 기본적인 연결리스트
2. Doubly Linked List\
각 노드에 이전 노드를 가리키는 포인터를 하나 더 추가한다. 노드들은 두 개의 포인터를 가지게 된다.
3. Circular Linked List\
마지막 노드인 테일(Tail)의 포인터를 첫번째 노드로 이어준 연결리스트이다.

#### 참조
  + https://opentutorials.org/module/1335/8636
  + https://wayhome25.github.io/cs/2017/04/17/cs-18-1/
  
*****

## Stack and Queue

+ 설명

추가와 삭제에 대하여 원소의 순서가 영향을 끼치는 선형 자료구조이다.\
나도 이과라서 글은 잼병이고 잘 못쓰겠으니 그냥 아래 설명을 보자.

### Stack

+ 용어
1. Top : 가장 위에 존재하는 원소의 위치를 가리키고 있는 인덱스 혹은 포인터.

+ 특징
1. 나중에 들어간 원소가 먼저 나오는 LIFO(Last In First Out) 조건을 가진다.

+ 예시 사진

![Stack1](../image/1.1%20Stack1.png)

+ 활용 예시
1. 함수의 지역변수, 매개변수의 메모리 할당 / 해제의 기본 구조로 쓰인다.
2. DFS(깊이우선탐색) 알고리즘에서 사용된다.
3. 문자를 거꾸로 쓰는 프로그램에 사용된다.

### Queue

+ 용어
1. enqueue : 큐에 데이터를 저장한다는 의미. 
2. dequeue : 큐에서 데이터를 뺀다는 의미. 큐에 들어있는 데이터 중 가장 오래된 데이터를 가져온다.
3. front : enqueue를 할 때 큐에서 뺄 데이터의 위치를 의미한다.
4. rear : dequeue를 할 때 큐에 넣을 데이터의 위치를 의미한다.
5. Overflow(오버플로우) : 더 이상 큐에 데이터를 저장할 수 없는 상태
6. Underflow(언더플로우) : 큐에 저장된 데이터가 없어서 데이터를 가져올 수 없는 상태

+ 특징
1. 나중에 들어간 원소가 먼저 나오는 FIFO(First In First Out) 조건을 가진다.

+ 종류
1. Queue\
가장 일반적인 큐

(아래사진은 위에서 아래, 왼쪽에서 오른쪽 순서이다.)\
<img src="../image/1.1%20Queue1.PNG" width="50%" height="50%">

2. Circular Queue(환형 큐 / 원형 큐)\
큐의 남는 저장 공간을 활용하기 위한 방식.

(아래사진은 왼쪽에서 오른쪽, 위에서 아래 순서이다.)\
![Queue2](../image/1.1%20Queue2.PNG)

3. Linked Queue\
LinkedList와 같이 인덱스가 아닌 포인터를 사용하여 다음 노드를 찾으며\
데이터를 넣고 뺄때는 큐와 같이 FIFO를 사용하는 큐.\
오버플로우가 발생하지 않는 것이 특징이다.

+ 활용 예시
1. 인쇄기 대기열같은 일반적인 대기줄 / 대기열에 사용된다.
2. DFS(너비우선탐색) 알고리즘에서 사용된다.

### Graph

+ 정의

노드(node)와 그 노드를 연결하는 간선(edge)의 집합을 의미한다.\
**네트워크 모델**을 만들기 위해서 사용되었다고 한다. (실재로 그래프와 관련된 문제는 네트워크를 주제로 했던 문제가 많았던 것 같다.)

+ 용어

1. 노드(node) / 버텍스(vertex) : 그래프 상의 특정 위치나 점을 의미
2. 간선(edge, link, branch) : 노드와 노드를 잇는 선을 의미 <img src="../image/1.1%20Graph1.PNG" width="5%" height="5%">
3. 자체 간선(self-loops) : 자신에서 시작하여 자신으로 들어오는 간선
3. 가중치(weight) : 간선에 부여된 비용, 시간, 중요도 등을 의미한다. 언급이 없다면 모든 간선의 가중치가 같다고 생각한다.
3. 인접(adjacent) : 정점 u, v가 있고 이 두 정점을 잇는 간선 e가 있다고 가정할 때 정점 u, v는 e로 인해 서로 인접한다고 말한다.. 
3. 부속(incident) : 위와 같은 상황에서 간선 e는 정점 u, v에 부속한다고 말한다.
4. 차수(degree) : 무향 그래프에서 하나의 노드에 연결되어있는 간선의 수
5. in-degree : 방향 그래프에서 노드로 들어오는 간선의 수
6. out-degree : 방향 그래프에서 노드에서 나가는 간선의 수
7. 경로(path) : 노드 a에서 노드 b로 가는 과정을 의미한다. 여러 개가 존재할 수 있으며 아예 없을 수도 있다.
8. 경로 길이(path length) : 경로를 구성하는 데 사용된 간선의 수
9. 사이클(cycle, 순환) : 시작 정점과 종료 정점이 동일한 경우
10. 단순 경로(simple path) : 사이클을 구성하는 노드가 시작 노드와 마지막 노드를 제외하고 중복이 없는 경우
11. 비순환(acycle) : 사이클이 아닌 경우

+ 종류

1. 유향 그래프(Directed graph) / 무향 그래프(Undirected graph)\
간선에 방향성이 있는 그래프 / 간선에 방향성이 없는 그래프, 양방향 유향그래프라고 생각해도 무방하다.
2. 가중치 그래프(Weighted graph)\
각 간선에 가중치가 부여된 그래프
4. 완전 그래프(Complete graph)\
각 노드가 자신을 제외한 모든 노드에 연결된 그래프
5. Dense graph / Sparse graph\
노드의 수보다 간선의 수가 많은 그래프 / 노드의 수보다 간선의 수가 적은 그래프
5. 순환 그래프(Cycle graph) / 비순환 그래프(Acycle graph)\
사이클인 경로가 하나라도 있는 그래프 / 사이클인 경로가 하나도 없는 그래프
7. **트리(Tree)**\
순환 그래프가 아닌 유향 그래프
8. 연결 그래프(Connected graph) / 비연결 그래프(Disconnected graph)\
무방향 그래프에 있는 모든 정점쌍에 대해서 항상 경로가 존재하는 경우 / 특정 정점쌍 하나라도 경로가 존재하지 않는 경우

+ 특징 (트리와의 차이점)
1. 그래프는 **네트워크 모델**이다.
2. 2개 이상의 경로가 가능하다.
3. self-loop와 사이클이 있을 수 있다.
4. 루트 노드라는 개념이 없다.
5. 부모-자식 관계라는 개념이 없다.
6. 순회는 DFS나 BFS로 이루어진다.
7. 그래프는 순환(Cyclic) 혹은 비순환(Acyclic) 둘 중 하나이다.
8. 노드에 간선이 있을수도 없을수도 있다.

#### 그래프 표현 방법

##### 인접 행렬(adjacent matrix) - 행렬을 사용
NxN BooleanMatrix(일반적으로 2차원 배열로 구현)을 만든 뒤 행렬에 간선의 유무를 적어놓는 방식이다.

간선의 유무는 O(1)로 파악할 수 있지만\
특정 노드에서 인접한 모든 노드를 찾는 속도는 O(V)로 느린편이다.
공간 복잡도는 V^2이다.\
Dense graph를 표현할 때 좋다.
> <img src="../image/1.1%20Graph7.png" width="35%" height="35%">

##### 인접 리스트(adjacent list) - 연결 리스트 사용
배열(혹은 해시테이블)과 배열의 각 인덱스마다 존재하는 또 다른 리스트(Array, ArrayList, 연결리스트(LinkedList) 등)를 이용하여 표현한다.\
그래프를 표현하는 일반적인 방법이다. 위에서 그래프의 가본이 되는 자료형이 LinkedList라고 했던 이유이다.

간선의 유무는 *관련된 노드의 차수만큼의 시간*으로 파악할 수 있고\
특정 노드에 인접한 모든 노드를 찾는 속도 위와 같으며 이것은 행렬에 비해서 상대적으로 빠르다. 애초에 인접한 노드들만 저장을 했기 때문이다.\
각 노드와 관계가 있는 간선만을 저장하므로 공간 복잡도는 V+E이다.\
Sparse graph를 표현할 때 좋다.
> <img src="../image/1.1%20Graph6.png" width="40%" height="40%">

+ 무/유향 그래프에서의 그래프 표현

<img src="../image/1.1%20Graph2.PNG" width="40%" height="40%"> <img src="../image/1.1%20Graph3.PNG" width="40%" height="40%">

+ 가중 무/유향 그래프에서의 그래프 표현

<img src="../image/1.1%20Graph4.PNG" width="40%" height="40%"> <img src="../image/1.1%20Graph5.PNG" width="40%" height="40%">

#### 그래프 탐색

##### 깊이 우선 탐색(Depth First Search: DFS)



##### 너비 우선 탐색(Breadth First Search: BFS)


