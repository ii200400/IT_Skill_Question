# 1-1. 자료구조
+ Array and List
+ Stack and Queue
+ Graph
+ Tree
+ heap
+ Hash

*****

## 자료구조의 필요성

    전산학에서 자료를 효율적으로 이용할 수 있도록 컴퓨터에 저장하는 방법이다. 
    신중히 선택한 자료구조는 보다 효율적인 알고리즘을 사용할 수 있게 한다. 
    이러한 자료구조의 선택문제는 대개 추상적 자료구조의 선택으로부터 시작하는 경우가 많다. 
    효과적으로 설계된 자료구조는 실행시간 혹은 메모리 용량 등의 자원을 최소한으로 사용하면서 연산을 수행하도록 한다. 
    - 위키백과 -

즉, 제한된 컴퓨터 자원에서 최대한의 효율을 뽑기 위해서 만들어진 선조들의 노오력의 산물이라는 것이다.\
cpu와 메모리가 끔찍할 정도로 강력해진 현재에 와서는 그 필요성이 많이 줄어들었지만 여전히 컴퓨터에서 너무나도 중요한 내용이다.\
같은 문제를 풀어도 자료구조를 아는 사람이 모르는 사람보다 더 짧은 코딩으로 더 빠른 알고리즘을 만드는 경우가 많으며\
아무리 cpu와 메모리가 강력해진다 하더라도 그만큼 사람들이 더 어려운 문제를(빅데이터, AI 등) 컴퓨터를 활용하여 처리하기 때문이다.

코드 구현부분은 제외하였다. 페이지가 너무 길어지고 아니라 구현방법도 사람마다 다르다.\
필자는 개인적으로 알고리즘을 코딩테스트가 가능한 사이트에서 알고리즘을 먼저 공부하고 자료구조를 공부하는 것을 추천한다.\
여기에 서술할 자료구조 정도는 코통 코딩테스트에서 못해도 한번씩은 다루며 \
코딩을 하는 과정에서 자료구조를 자연스럽게 습득하는 경우가 많기 때문이다.

*****

## Array and List

+ 시작하기 전에..

Array and List는 가장 흔하게 볼 수 있는 순차적(선형) 자료구조이다. \
그런데 이 두 자료구조의 이름 중 하나(ArrayList)에 의아함을 느껴 깊이 알아보게 되었다.

인터넷에서 Array라고 쓰이는 것은 일반적으로 ArrayList이다. 나는 이것을 구분해서 서술할 것이다.\
면접에서 배열과 연결 리스트의 차이점을 서술하라고 하면 이 페이지의 ArrayList와 LinkedList의 차이를 설명하라는 것과 같다.

혼란을 줄이기 위해서 대표적인 차이점을 먼저 설명하자면\
Array는 원소의 값이 null값을 가질 수 있고\
ArrayList는 원소의 값이 null값을 가질 수 없으며\
LinkedList는 원소의 값이 null값을 가질 수 없으면서 인덱스 대신 포인터를 가지는 자료구조이다.\
차이점을 잘 설명해준 [opentutorials](https://opentutorials.org/module/1335/8636)에게 감사하다.

### Array

+ 설명

랜덤 접근이 가능한 순차적 자료구조이다.\
**원소를 삭제하더라도 그 자리는 다른 원소가 차지하지 못한다. 빈 장소를 그대로 방치한다.**

+ 특징

1. 논리적 저장 순서와 물리적 저장 순서가 일치(index)하는 순차적인 자료구조이다. 
2. 위의 이유로 index를 사용하여 O(1)에 원하는 원소로 접근이 가능하다. \
  random access가 가능하다고 한다.
3. 원소의 삭제, 삽입이 O(1)에 끝난다.
4. 마지막 자리에만 원소를 추가할 수 있다.
5. 원소를 삭제할 때마다 빈 메모리가 생기기 때문에 메모리를 효율적으로 사용하지 못 한다.
6. 재할당을 하지 않는 이상 최대 원소의 갯수는 제한적이다.

+ 예시

순서대로 10, 20, 30, 40, 50을 Array에 넣은 후 40을 삭제하면 다음의 그림이 된다.
![Array1](../image/1.1%20Array1.jpg)

### ArrayList

+ 설명

랜덤 접근이 가능한 순차적 자료구조이다.\
Array에서 null 값을 가지는 원소를 허용하지 않는 방법이다.\
**Array가 아니라 List의 한 종류이다**\
자바 기준으로 List는 인터페이스이고 ArrayList, LinkedList 들은 List에 상속된 클래스들이라고 한다.

+ 특징 

1. 논리적 저장 순서와 물리적 저장 순서가 일치하는 순차적인 자료구조이다. 
2. index를 사용하여 O(1)에 원하는 원소로 접근이 가능하다. 
3. 빈 부분이 없어야 하기 때문에 한 원소를 삭제하면 그 자리를 뒤의 원소들이 한 칸씩 앞으로 와서 매꾸어 주어야 한다. \
  이때 O(n)의 시간이 소모된다. (삽입도 마찬가지로 한 요소가 들어갈 자리를 만들기 위해 원소들이 한 칸씩 뒤로 빠져야 해서 같은 시간이 소모된다.)
2. 재할당을 하지 않는 이상 최대 원소의 갯수는 제한적이다.

+ 예시

순서대로 10, 20, 30, 40, 50을 ArrayList에 넣은 후 40을 삭제하면 다음의 그림이 된다.
![ArrayList1](../image/1.1%20ArrayList1.png)

### LinkedList (연결리스트)

+ 용어
1. 노드(node) / 버텍스(vertex) : LinkedList의 원소를 부를 때 쓰이는 용어
1. 데이터(Data) : 노드의 값을 저장하는 부분이다. 보통 변수명을 **value**로 한다.
1. 포인터 / 링크(Link) : 동적 할당의 포인터와 같은 의미, 다른 노드의 주소를 저장한다. 보통 변수명을 **next**로 한다.
1. 헤드(Head) : 첫 노드를 가리키는 **포인터**. first라고 표현하기도 한다.
1. 테일(Tail) : 마지막 **노드**를 의미한다. end라고 표현하기도 한다.

+ 설명

**랜덤 접근이 불가능한** 순차적 자료구조이다.\
연결리스트는 노드(node) 혹은 버텍스(vertex)라고 불리는 것들로 구성되어 있다.\
노드는 저장할 값(데이터)과 다음 노드를 가리키는 포인터(링크)로 이루어져 있다.\
연결리스트의 헤드(Head)를 시작으로 각 노드의 포인터를 사용하여리스트를 순회할 수 있게 한다.\
**트리(Tree)와 그래프(Graph)의 기본 자료형이다.**

+ 특징

1. 각 노드의 저장 위치는 관련된 노드의 포인터를 통해 알 수 있다.\
  즉, n 번째 원소는 n-1번의 포인트를 찾아가야 하므로 O(n)의 탐색시간이 걸린다.
2. 삭제나 삽입 자체만 생각하면 연관된 노드의 포인터의 값만 바꿔주면 되므로 O(1)이 걸린다.\
  하지만 삭제나 삽입할 위치를 탐색하는 것이 위에서 말한데로 O(n)의 시간이 걸리므로 결과적으로는 O(n)의 시간이 걸린다.
3. 노드를 동적으로 추가, 삭제할 수 있다.

+ 예시

순서대로 10, 20, 30, 40를 LinkedList에 넣었을 때 다음의 그림이 된다.
![LinkedList1](../image/1.1%20LinkedList1.png)

+ 종류
1. Singly Linked List\
가장 기본적인 연결리스트
2. Doubly Linked List\
각 노드에 이전 노드를 가리키는 포인터를 하나 더 추가한다. 노드들은 두 개의 포인터를 가지게 된다.
3. Circular Linked List\
환형 큐(Circular Queue)와 같이 마지막 노드인 테일(Tail)과 헤드를 이어준 연결리스트이다.

#### 참조
  + https://opentutorials.org/module/1335/8636
  + https://wayhome25.github.io/cs/2017/04/17/cs-18-1/
  
*****

## Stack and Queue

+ 설명

추가와 삭제에 대하여 원소의 순서가 영향을 끼치는 선형 자료구조이다.\
잘 모르겠으면 그냥 아래 설명을 보자.

### Stack

+ 용어
1. Top : 가장 위에 존재하는 원소의 위치를 가리키고 있는 인덱스 혹은 포인터.

+ 특징
1. 나중에 들어간 원소가 먼저 나오는 LIFO(Last In First Out) 조건을 가진다.

+ 예시


### Queue

+ 용어
1. enqueue : 
2. dequeue : 
3. 

+ 특징
1. 나중에 들어간 원소가 먼저 나오는 FIFO(First In First Out) 조건을 가진다.

+ 종류
1. Queue
가장 일반적인 큐
2. Circular Queue(환형 큐 / 원형 큐)
일반적인 큐의 남는 저장 공간을 활용하기 위한 방식.
3. Linked Queue
LinkedList와 같은 저장 방식을 따르지만 데이터를 저장하고 가져오는 조건은 큐를 따른 방식.


+ 예시


